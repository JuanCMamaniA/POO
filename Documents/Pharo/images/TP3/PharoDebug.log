THERE_BE_DRAGONS_HERE
[delaySemaphore wait] in Delay>>wait
9 April 2023 10:27:20.772 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

[delaySemaphore wait] in Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3858542840732000


FullBlockClosure(BlockClosure)>>ifCurtailed:
	Receiver: [delaySemaphore wait]
	Arguments and temporary variables: 
		aBlock: 	[self unschedule]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	a CompiledBlock: [delaySemaphore wait]
		numArgs: 	0
		receiver: 	a Delay(16 msecs)


Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3858542840732000


WorldState class>>doInterCycleWait
	Receiver: WorldState
	Arguments and temporary variables: 
		waitTime: 	16
		newCycleTime: 	10952390
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	true
		returnValue: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	a CompiledBlock: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	...etc...
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
9 April 2023 10:27:20.8 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

[delaySemaphore wait] in Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3858542840732000


FullBlockClosure(BlockClosure)>>ifCurtailed:
	Receiver: [delaySemaphore wait]
	Arguments and temporary variables: 
		aBlock: 	[self unschedule]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	Delay>>wait
		startpc: 	a CompiledBlock: [delaySemaphore wait]
		numArgs: 	0
		receiver: 	a Delay(16 msecs)


Delay>>wait
	Receiver: a Delay(16 msecs)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	16
		ticker: 	a DelayMicrosecondTicker
		resumptionTick: 	3858542840732000


WorldState class>>doInterCycleWait
	Receiver: WorldState
	Arguments and temporary variables: 
		waitTime: 	16
		newCycleTime: 	10952390
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	true
		returnValue: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph


WorldState class>>doDrawCycleWith:
	Receiver: WorldState
	Arguments and temporary variables: 
		aBlock: 	[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex c...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#activeHand->WorldState>>#activeHand #activeHand...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldState}
		name: 	#WorldState
		classPool: 	a Dictionary(#CanSurrenderToOS->nil #DebugShowDamage->false #Deferre...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


MorphicRenderLoop>>doOneCycle
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
a MorphicRenderLoop

MorphicRenderLoop>>doOneCycleWhile:
	Receiver: a MorphicRenderLoop
	Arguments and temporary variables: 
		aBlock: 	[ true ]
	Receiver's instance variables: 
a MorphicRenderLoop

[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		activeTranscript: 	nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	a CompiledBlock: [
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	...etc...
		numArgs: 	0
		receiver: 	a MorphicUIManager



--- The full stack ---
[delaySemaphore wait] in Delay>>wait
FullBlockClosure(BlockClosure)>>ifCurtailed:
Delay>>wait
WorldState class>>doInterCycleWait
[
		self doInterCycleWait
	] in WorldState class>>doDrawCycleWith:
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: a ClyNotebookPageMorph(771380992) not found in SortedCollection
10 April 2023 4:57:51.142 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SortedCollection(Collection)>>errorNotFound:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		anObject: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


[self errorNotFound: oldObject] in SortedCollection(Collection)>>remove:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		oldObject: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


SortedCollection(OrderedCollection)>>remove:ifAbsent:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		oldObject: 	a ClyNotebookPageMorph(771380992)
		absentBlock: 	[self errorNotFound: oldObject]
		index: 	20
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


SortedCollection(Collection)>>remove:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		oldObject: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


[ 
		self pages remove: aPage.
		self tabSelectorMorph removeTabIndex: removedPageIndex ] in ClyNotebookMorph(SpNotebookMorph)>>removePage:
	Receiver: a ClyNotebookMorph(566529536)
	Arguments and temporary variables: 
		aPage: 	a ClyNotebookPageMorph(771380992)
		removedPageIndex: 	0
	Receiver's instance variables: 
		bounds: 	(367.0@389.0) corner: (1276.0@627.0)
		owner: 	a PanelMorph(183172096)
		submorphs: 	an Array(a PanelMorph(793695744) a PanelMorph(786924544))
		fullBounds: 	(367@389) corner: (1276@627)
		color: 	Color transparent
		extension: 	a MorphExtension (482170624) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	0
		borderColor: 	Color yellow
		model: 	nil
		tabSelectorMorph: 	a SpNotebookTabSelectorMorph(988819456)
		contentMorph: 	a PanelMorph(793695744)
		pageMorphs: 	a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPa...etc...
		headerMorph: 	a PanelMorph(786924544)
		toolbarMorph: 	a SpNotebookPanelMorph(312131840)


ClyNotebookMorph(SpNotebookMorph)>>suspendAnnouncementsDuring:
	Receiver: a ClyNotebookMorph(566529536)
	Arguments and temporary variables: 
		aBlock: 	[ 
		self pages remove: aPage.
		self tabSelectorMorph removeTabIndex: ...etc...
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
	Receiver's instance variables: 
		bounds: 	(367.0@389.0) corner: (1276.0@627.0)
		owner: 	a PanelMorph(183172096)
		submorphs: 	an Array(a PanelMorph(793695744) a PanelMorph(786924544))
		fullBounds: 	(367@389) corner: (1276@627)
		color: 	Color transparent
		extension: 	a MorphExtension (482170624) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	0
		borderColor: 	Color yellow
		model: 	nil
		tabSelectorMorph: 	a SpNotebookTabSelectorMorph(988819456)
		contentMorph: 	a PanelMorph(793695744)
		pageMorphs: 	a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPa...etc...
		headerMorph: 	a PanelMorph(786924544)
		toolbarMorph: 	a SpNotebookPanelMorph(312131840)


ClyNotebookMorph(SpNotebookMorph)>>removePage:
	Receiver: a ClyNotebookMorph(566529536)
	Arguments and temporary variables: 
		aPage: 	a ClyNotebookPageMorph(771380992)
		removedPageIndex: 	0
	Receiver's instance variables: 
		bounds: 	(367.0@389.0) corner: (1276.0@627.0)
		owner: 	a PanelMorph(183172096)
		submorphs: 	an Array(a PanelMorph(793695744) a PanelMorph(786924544))
		fullBounds: 	(367@389) corner: (1276@627)
		color: 	Color transparent
		extension: 	a MorphExtension (482170624) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	0
		borderColor: 	Color yellow
		model: 	nil
		tabSelectorMorph: 	a SpNotebookTabSelectorMorph(988819456)
		contentMorph: 	a PanelMorph(793695744)
		pageMorphs: 	a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPa...etc...
		headerMorph: 	a PanelMorph(786924544)
		toolbarMorph: 	a SpNotebookPanelMorph(312131840)


ClyNotebookManager>>closeTab:
	Receiver: a ClyNotebookManager
	Arguments and temporary variables: 
		tab: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		browser: 	a ClyFullBrowserMorph(554208256)
		tabMorph: 	a ClyNotebookMorph(566529536)
		tools: 	a SortedCollection(a ClyClassCommentEditorToolMorph(872273664) a ClyClas...etc...
		updatingStarted: 	false
		selectionPriorities: 	an IdentityDictionary(ClyClassCommentEditorToolMorph->9 Cl...etc...
		desiredSelection: 	an IdentitySet(ClyMethodCreationToolMorph)
		shouldSkipCurrentDesiredSelection: 	false


[ self closeTab: tab ] in ClyNotebookManager>>addTool:
	Receiver: a ClyNotebookManager
	Arguments and temporary variables: 
		aBrowserTool: 	a ClyMethodCreationToolMorph(462966272)
		tab: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		browser: 	a ClyFullBrowserMorph(554208256)
		tabMorph: 	a ClyNotebookMorph(566529536)
		tools: 	a SortedCollection(a ClyClassCommentEditorToolMorph(872273664) a ClyClas...etc...
		updatingStarted: 	false
		selectionPriorities: 	an IdentityDictionary(ClyClassCommentEditorToolMorph->9 Cl...etc...
		desiredSelection: 	an IdentitySet(ClyMethodCreationToolMorph)
		shouldSkipCurrentDesiredSelection: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self closeTab: tab ]
	Arguments and temporary variables: 
		anArg: 	a ClyNotebookPageHeaderPresenter
	Receiver's instance variables: 
		outerContext: 	ClyNotebookManager>>addTool:
		startpc: 	a CompiledBlock: [ self closeTab: tab ]
		numArgs: 	0
		receiver: 	a ClyNotebookManager


ClyNotebookPageHeaderPresenter>>doClose
	Receiver: a ClyNotebookPageHeaderPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		pageMorph: 	a ClyNotebookPageMorph(771380992)
		iconImage: 	a SpImagePresenter
		titleLabel: 	a SpLabelPresenter
		closeImage: 	a SpImagePresenter
		closeAction: 	[ self closeTab: tab ]
		doubleClickAction: 	[ browser toggleFullWindowTabs ]


[ :anEvent | 
			anEvent isPrimaryButton 
				ifTrue: [ self doClose ] ] in ClyNotebookPageHeaderPresenter>>initializePresenters
	Receiver: a ClyNotebookPageHeaderPresenter
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		pageMorph: 	a ClyNotebookPageMorph(771380992)
		iconImage: 	a SpImagePresenter
		titleLabel: 	a SpLabelPresenter
		closeImage: 	a SpImagePresenter
		closeAction: 	[ self closeTab: tab ]
		doubleClickAction: 	[ browser toggleFullWindowTabs ]


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		sourceMorph: 	an AlphaImageMorph(449848832)
		arity: 	1
	Receiver's instance variables: 
		event: 	#mouseDown
		selector: 	#value:
		recipient: 	[ :anEvent | 
			anEvent isPrimaryButton 
				ifTrue: [ self doClose...etc...
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		eventType: 	#mouseDown
		sourceMorph: 	an AlphaImageMorph(449848832)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseDown->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) == tru...etc...
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		eventType: 	#mouseDown
		sourceMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseDown->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseDown:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(695@349) mouseDown red 12091716 nil]
		sourceMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseDown->a Set(a MorphEventSubscription) )


AlphaImageMorph(Morph)>>handleMouseDown:
	Receiver: an AlphaImageMorph(449848832)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(393674240)
		submorphs: 	#()
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (613893888) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(16x16x32)
		alpha: 	1.0
		cachedForm: 	Form(16x16x32)
		layout: 	#center
		scale: 	1.0
		enabled: 	true
		autoSize: 	true
		getImageSelector: 	#getImage
		model: 	a SpMorphicImageAdapter


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	an AlphaImageMorph(449848832)
		wasHandled: 	true
		whichButton: 	4


AlphaImageMorph(Morph)>>handleEvent:
	Receiver: an AlphaImageMorph(449848832)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(393674240)
		submorphs: 	#()
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (613893888) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(16x16x32)
		alpha: 	1.0
		cachedForm: 	Form(16x16x32)
		layout: 	#center
		scale: 	1.0
		enabled: 	true
		autoSize: 	true
		getImageSelector: 	#getImage
		model: 	a SpMorphicImageAdapter


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	an AlphaImageMorph(449848832)
		globalPt: 	(695@349)
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		handler: 	an AlphaImageMorph(449848832)
		inside: 	nil
		lastHandler: 	a TabLabelMorph(702713344)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	an AlphaImageMorph(449848832)
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		morph: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		morph: 	nil


AlphaImageMorph(Morph)>>processEvent:using:
	Receiver: an AlphaImageMorph(449848832)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(393674240)
		submorphs: 	#()
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (613893888) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(16x16x32)
		alpha: 	1.0
		cachedForm: 	Form(16x16x32)
		layout: 	#center
		scale: 	1.0
		enabled: 	true
		autoSize: 	true
		getImageSelector: 	#getImage
		model: 	a SpMorphicImageAdapter


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(393674240)
		globalPt: 	(695@349)
		localEvt: 	[(695@349) mouseDown red 12091716 nil]
		index: 	1
		child: 	an AlphaImageMorph(449848832)
		morphs: 	an Array(an AlphaImageMorph(449848832))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a TabLabelMorph(702713344)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	a TabLabelMorph(702713344)
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(393674240)
	Receiver's instance variables: 
		morph: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(393674240)
	Receiver's instance variables: 
		morph: 	nil


Morph>>processEvent:using:
	Receiver: a Morph(393674240)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(1033470976)
		submorphs: 	an Array(an AlphaImageMorph(449848832))
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (917976832) [sticky] 


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(1033470976)
		globalPt: 	(695@349)
		localEvt: 	[(695@349) mouseDown red 12091716 nil]
		index: 	2
		child: 	a Morph(393674240)
		morphs: 	an Array(a Morph(418263040) a Morph(393674240))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a TabLabelMorph(702713344)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	a TabLabelMorph(702713344)
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(1033470976)
	Receiver's instance variables: 
		morph: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher



--- The full stack ---
SortedCollection(Collection)>>errorNotFound:
[self errorNotFound: oldObject] in SortedCollection(Collection)>>remove:
SortedCollection(OrderedCollection)>>remove:ifAbsent:
SortedCollection(Collection)>>remove:
[ 
		self pages remove: aPage.
		self tabSelectorMorph removeTabIndex: removedPageIndex ] in ClyNotebookMorph(SpNotebookMorph)>>removePage:
ClyNotebookMorph(SpNotebookMorph)>>suspendAnnouncementsDuring:
ClyNotebookMorph(SpNotebookMorph)>>removePage:
ClyNotebookManager>>closeTab:
[ self closeTab: tab ] in ClyNotebookManager>>addTool:
FullBlockClosure(BlockClosure)>>cull:
ClyNotebookPageHeaderPresenter>>doClose
[ :anEvent | 
			anEvent isPrimaryButton 
				ifTrue: [ self doClose ] ] in ClyNotebookPageHeaderPresenter>>initializePresenters
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseDown:fromMorph:
AlphaImageMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
AlphaImageMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
AlphaImageMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TabLabelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpNotebookTabSelectorMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyNotebookMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyFullBrowserMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: a ClyNotebookPageMorph(771380992) not found in SortedCollection
10 April 2023 4:57:51.288 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SortedCollection(Collection)>>errorNotFound:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		anObject: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


[self errorNotFound: oldObject] in SortedCollection(Collection)>>remove:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		oldObject: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


SortedCollection(OrderedCollection)>>remove:ifAbsent:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		oldObject: 	a ClyNotebookPageMorph(771380992)
		absentBlock: 	[self errorNotFound: oldObject]
		index: 	20
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


SortedCollection(Collection)>>remove:
	Receiver: a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPageMorph(764965120) a Cl...etc...
	Arguments and temporary variables: 
		oldObject: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		array: 	an Array(nil nil nil nil nil nil nil nil nil nil nil nil nil a ClyNotebo...etc...
		firstIndex: 	14
		lastIndex: 	19
		sortBlock: 	[ :a :b | (self tabOrderOf: a) <= (self tabOrderOf: b) ]


[ 
		self pages remove: aPage.
		self tabSelectorMorph removeTabIndex: removedPageIndex ] in ClyNotebookMorph(SpNotebookMorph)>>removePage:
	Receiver: a ClyNotebookMorph(566529536)
	Arguments and temporary variables: 
		aPage: 	a ClyNotebookPageMorph(771380992)
		removedPageIndex: 	0
	Receiver's instance variables: 
		bounds: 	(367.0@389.0) corner: (1276.0@627.0)
		owner: 	a PanelMorph(183172096)
		submorphs: 	an Array(a PanelMorph(793695744) a PanelMorph(786924544))
		fullBounds: 	(367@389) corner: (1276@627)
		color: 	Color transparent
		extension: 	a MorphExtension (482170624) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	0
		borderColor: 	Color yellow
		model: 	nil
		tabSelectorMorph: 	a SpNotebookTabSelectorMorph(988819456)
		contentMorph: 	a PanelMorph(793695744)
		pageMorphs: 	a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPa...etc...
		headerMorph: 	a PanelMorph(786924544)
		toolbarMorph: 	a SpNotebookPanelMorph(312131840)


ClyNotebookMorph(SpNotebookMorph)>>suspendAnnouncementsDuring:
	Receiver: a ClyNotebookMorph(566529536)
	Arguments and temporary variables: 
		aBlock: 	[ 
		self pages remove: aPage.
		self tabSelectorMorph removeTabIndex: ...etc...
		subscriptions: 	an IdentitySet(an AnnouncementSubscription)
	Receiver's instance variables: 
		bounds: 	(367.0@389.0) corner: (1276.0@627.0)
		owner: 	a PanelMorph(183172096)
		submorphs: 	an Array(a PanelMorph(793695744) a PanelMorph(786924544))
		fullBounds: 	(367@389) corner: (1276@627)
		color: 	Color transparent
		extension: 	a MorphExtension (482170624) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	0
		borderColor: 	Color yellow
		model: 	nil
		tabSelectorMorph: 	a SpNotebookTabSelectorMorph(988819456)
		contentMorph: 	a PanelMorph(793695744)
		pageMorphs: 	a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPa...etc...
		headerMorph: 	a PanelMorph(786924544)
		toolbarMorph: 	a SpNotebookPanelMorph(312131840)


ClyNotebookMorph(SpNotebookMorph)>>removePage:
	Receiver: a ClyNotebookMorph(566529536)
	Arguments and temporary variables: 
		aPage: 	a ClyNotebookPageMorph(771380992)
		removedPageIndex: 	0
	Receiver's instance variables: 
		bounds: 	(367.0@389.0) corner: (1276.0@627.0)
		owner: 	a PanelMorph(183172096)
		submorphs: 	an Array(a PanelMorph(793695744) a PanelMorph(786924544))
		fullBounds: 	(367@389) corner: (1276@627)
		color: 	Color transparent
		extension: 	a MorphExtension (482170624) [other:  (announcer -> an Announcer) (k...etc...
		borderWidth: 	0
		borderColor: 	Color yellow
		model: 	nil
		tabSelectorMorph: 	a SpNotebookTabSelectorMorph(988819456)
		contentMorph: 	a PanelMorph(793695744)
		pageMorphs: 	a SortedCollection(a ClyNotebookPageMorph(44574464) a ClyNotebookPa...etc...
		headerMorph: 	a PanelMorph(786924544)
		toolbarMorph: 	a SpNotebookPanelMorph(312131840)


ClyNotebookManager>>closeTab:
	Receiver: a ClyNotebookManager
	Arguments and temporary variables: 
		tab: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		browser: 	a ClyFullBrowserMorph(554208256)
		tabMorph: 	a ClyNotebookMorph(566529536)
		tools: 	a SortedCollection(a ClyClassCommentEditorToolMorph(872273664) a ClyClas...etc...
		updatingStarted: 	false
		selectionPriorities: 	an IdentityDictionary(ClyClassCommentEditorToolMorph->9 Cl...etc...
		desiredSelection: 	an IdentitySet(ClyMethodCreationToolMorph)
		shouldSkipCurrentDesiredSelection: 	false


[ self closeTab: tab ] in ClyNotebookManager>>addTool:
	Receiver: a ClyNotebookManager
	Arguments and temporary variables: 
		aBrowserTool: 	a ClyMethodCreationToolMorph(462966272)
		tab: 	a ClyNotebookPageMorph(771380992)
	Receiver's instance variables: 
		browser: 	a ClyFullBrowserMorph(554208256)
		tabMorph: 	a ClyNotebookMorph(566529536)
		tools: 	a SortedCollection(a ClyClassCommentEditorToolMorph(872273664) a ClyClas...etc...
		updatingStarted: 	false
		selectionPriorities: 	an IdentityDictionary(ClyClassCommentEditorToolMorph->9 Cl...etc...
		desiredSelection: 	an IdentitySet(ClyMethodCreationToolMorph)
		shouldSkipCurrentDesiredSelection: 	false


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ self closeTab: tab ]
	Arguments and temporary variables: 
		anArg: 	a ClyNotebookPageHeaderPresenter
	Receiver's instance variables: 
		outerContext: 	ClyNotebookManager>>addTool:
		startpc: 	a CompiledBlock: [ self closeTab: tab ]
		numArgs: 	0
		receiver: 	a ClyNotebookManager


ClyNotebookPageHeaderPresenter>>doClose
	Receiver: a ClyNotebookPageHeaderPresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		pageMorph: 	a ClyNotebookPageMorph(771380992)
		iconImage: 	a SpImagePresenter
		titleLabel: 	a SpLabelPresenter
		closeImage: 	a SpImagePresenter
		closeAction: 	[ self closeTab: tab ]
		doubleClickAction: 	[ browser toggleFullWindowTabs ]


[ :anEvent | 
			anEvent isPrimaryButton 
				ifTrue: [ self doClose ] ] in ClyNotebookPageHeaderPresenter>>initializePresenters
	Receiver: a ClyNotebookPageHeaderPresenter
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	nil
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a SpNullApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		pageMorph: 	a ClyNotebookPageMorph(771380992)
		iconImage: 	a SpImagePresenter
		titleLabel: 	a SpLabelPresenter
		closeImage: 	a SpImagePresenter
		closeAction: 	[ self closeTab: tab ]
		doubleClickAction: 	[ browser toggleFullWindowTabs ]


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		sourceMorph: 	an AlphaImageMorph(449848832)
		arity: 	1
	Receiver's instance variables: 
		event: 	#mouseDown
		selector: 	#value:
		recipient: 	[ :anEvent | 
			anEvent isPrimaryButton 
				ifTrue: [ self doClose...etc...
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		eventType: 	#mouseDown
		sourceMorph: 	an AlphaImageMorph(449848832)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseDown->a Set(a MorphEventSubscription) )


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) == tru...etc...
		index: 	2
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil a MorphEventSubscription nil nil nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		eventType: 	#mouseDown
		sourceMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseDown->a Set(a MorphEventSubscription) )


MorphicEventHandler>>mouseDown:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(695@349) mouseDown red 12091716 nil]
		sourceMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#mouseDown->a Set(a MorphEventSubscription) )


AlphaImageMorph(Morph)>>handleMouseDown:
	Receiver: an AlphaImageMorph(449848832)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		handler: 	a MorphicEventHandler
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(393674240)
		submorphs: 	#()
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (613893888) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(16x16x32)
		alpha: 	1.0
		cachedForm: 	Form(16x16x32)
		layout: 	#center
		scale: 	1.0
		enabled: 	true
		autoSize: 	true
		getImageSelector: 	#getImage
		model: 	a SpMorphicImageAdapter


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	an AlphaImageMorph(449848832)
		wasHandled: 	true
		whichButton: 	4


AlphaImageMorph(Morph)>>handleEvent:
	Receiver: an AlphaImageMorph(449848832)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(393674240)
		submorphs: 	#()
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (613893888) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(16x16x32)
		alpha: 	1.0
		cachedForm: 	Form(16x16x32)
		layout: 	#center
		scale: 	1.0
		enabled: 	true
		autoSize: 	true
		getImageSelector: 	#getImage
		model: 	a SpMorphicImageAdapter


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	an AlphaImageMorph(449848832)
		globalPt: 	(695@349)
		localEvt: 	nil
		index: 	1
		child: 	nil
		morphs: 	#()
		handler: 	an AlphaImageMorph(449848832)
		inside: 	nil
		lastHandler: 	a TabLabelMorph(702713344)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	an AlphaImageMorph(449848832)
		wasHandled: 	true
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		morph: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	an AlphaImageMorph(449848832)
	Receiver's instance variables: 
		morph: 	nil


AlphaImageMorph(Morph)>>processEvent:using:
	Receiver: an AlphaImageMorph(449848832)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(393674240)
		submorphs: 	#()
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (613893888) [eventHandler = a MorphicEventHandler] ...etc...
		image: 	Form(16x16x32)
		alpha: 	1.0
		cachedForm: 	Form(16x16x32)
		layout: 	#center
		scale: 	1.0
		enabled: 	true
		autoSize: 	true
		getImageSelector: 	#getImage
		model: 	a SpMorphicImageAdapter


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(393674240)
		globalPt: 	(695@349)
		localEvt: 	[(695@349) mouseDown red 12091716 nil]
		index: 	1
		child: 	an AlphaImageMorph(449848832)
		morphs: 	an Array(an AlphaImageMorph(449848832))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a TabLabelMorph(702713344)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	a TabLabelMorph(702713344)
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(393674240)
	Receiver's instance variables: 
		morph: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher


MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(393674240)
	Receiver's instance variables: 
		morph: 	nil


Morph>>processEvent:using:
	Receiver: a Morph(393674240)
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		defaultDispatcher: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		bounds: 	(831.0@335.0) corner: (847.0@355.0)
		owner: 	a Morph(1033470976)
		submorphs: 	an Array(an AlphaImageMorph(449848832))
		fullBounds: 	(831.0@335.0) corner: (847.0@355.0)
		color: 	Color transparent
		extension: 	a MorphExtension (917976832) [sticky] 


MorphicEventDispatcher>>dispatchMouseDown:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(1033470976)
		globalPt: 	(695@349)
		localEvt: 	[(695@349) mouseDown red 12091716 nil]
		index: 	2
		child: 	a Morph(393674240)
		morphs: 	an Array(a Morph(418263040) a Morph(393674240))
		handler: 	nil
		inside: 	nil
		lastHandler: 	a TabLabelMorph(702713344)
	Receiver's instance variables: 
		morph: 	nil


MorphicEventDispatcher>>handleMouseDown:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
	Receiver's instance variables: 
		morph: 	nil


MouseButtonEvent>>sentTo:
	Receiver: [(695@349) mouseDown red 12091716 nil]
	Arguments and temporary variables: 
		anObject: 	a MorphicEventDispatcher
	Receiver's instance variables: 
		timeStamp: 	12091716
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseDown
		buttons: 	4
		position: 	(695@349)
		handler: 	a TabLabelMorph(702713344)
		wasHandled: 	false
		whichButton: 	4


[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
	Receiver: a MorphicEventDispatcher
	Arguments and temporary variables: 
		anEvent: 	[(695@349) mouseDown red 12091716 nil]
		aMorph: 	a Morph(1033470976)
	Receiver's instance variables: 
		morph: 	nil


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ ^ anEvent sentTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ morph := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MorphicEventDispatcher>>dispatchEvent:with:
		startpc: 	a CompiledBlock: [ ^ anEvent sentTo: self ]
		numArgs: 	0
		receiver: 	a MorphicEventDispatcher



--- The full stack ---
SortedCollection(Collection)>>errorNotFound:
[self errorNotFound: oldObject] in SortedCollection(Collection)>>remove:
SortedCollection(OrderedCollection)>>remove:ifAbsent:
SortedCollection(Collection)>>remove:
[ 
		self pages remove: aPage.
		self tabSelectorMorph removeTabIndex: removedPageIndex ] in ClyNotebookMorph(SpNotebookMorph)>>removePage:
ClyNotebookMorph(SpNotebookMorph)>>suspendAnnouncementsDuring:
ClyNotebookMorph(SpNotebookMorph)>>removePage:
ClyNotebookManager>>closeTab:
[ self closeTab: tab ] in ClyNotebookManager>>addTool:
FullBlockClosure(BlockClosure)>>cull:
ClyNotebookPageHeaderPresenter>>doClose
[ :anEvent | 
			anEvent isPrimaryButton 
				ifTrue: [ self doClose ] ] in ClyNotebookPageHeaderPresenter>>initializePresenters
MorphEventSubscription>>notify:from:
[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
Set>>do:
MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
MorphicEventHandler>>mouseDown:fromMorph:
AlphaImageMorph(Morph)>>handleMouseDown:
MouseButtonEvent>>sentTo:
AlphaImageMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
AlphaImageMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
TabLabelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SpNotebookTabSelectorMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyNotebookMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PanelMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ClyFullBrowserMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
FullBlockClosure(BlockClosure)>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Pharo cannot write to the changes file named C:\Users\Usuario\Documents\Pharo\images\TP3\TP3.changes.

Please check that you have write permission for this file.

You won't be able to save this image correctly until you fix this.
10 April 2023 6:16:44.964 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

StartupUIManager>>inform:
	Receiver: a StartupUIManager
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to the changes file named C:\Users\Usuario\Documents\...etc...
		tmp1: 	nil
	Receiver's instance variables: 
		doNotQuitOnRestart: 	false
		uiManager: 	nil


PharoFilesOpener(Object)>>inform:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to the changes file named C:\Users\Usuario\Documents\...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>inform:withRef:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to &fileRef.

Please check that you have write permis...etc...
		arg2: 	'the changes file named C:\Users\Usuario\Documents\Pharo\images\TP3\TP3.c...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>inform:withChangesRef:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to &fileRef.

Please check that you have write permis...etc...
		arg2: 	'C:\Users\Usuario\Documents\Pharo\images\TP3\TP3.changes'
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>informProblemInChanges:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	'Pharo cannot write to &fileRef.

Please check that you have write permis...etc...
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>changesFileOrNilReadOnly:silent:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	false
		arg2: 	false
		tmp1: 	SourceFile(C:\Users\Usuario\Documents\Pharo\images\TP3\TP3.changes)
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>changesFileOrNilReadOnly:
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
		arg1: 	false
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


PharoFilesOpener>>changesFileOrNil
	Receiver: a PharoFilesOpener
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		shouldInformAboutReadOnlyChanges: 	true


SourceFileArray>>ensureOpen
	Receiver: a SourceFileArray
	Arguments and temporary variables: 
		tmp1: 	SourceFile(C:\Users\Usuario\Documents\Pharo\images\TP3\Pharo10.0-64bit-17...etc...
		tmp2: 	nil
	Receiver's instance variables: 
		files: 	#(nil nil)
		readOnlyQueue: 	SharedQueue with 0 items
		flushChanges: 	true


SmalltalkImage>>openSourceFiles
	Receiver: Smalltalk
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		globals: 	a SystemDictionary(lots of globals)
		specialObjectsArray: 	an Array(nil false true #Processor->Processor Bitmap Small...etc...
		vm: 	a VirtualMachine


SourceFileArray class>>startUp:
	Receiver: SourceFileArray
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#changeRecordsFor:->SourceFileArray>>#changeReco...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SourceFileArray
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'System-Sources-Sources'


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(SourceFileArray)
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		registeredClassName: 	#SourceFileArray


[ :arg2 | arg2 startup: arg1 ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	true
		arg2: 	a ClassSessionHandler(SourceFileArray)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2023-04-10T18:16:44.852-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


[ arg2 value: arg3 ] in [ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(Sessio...etc...
		arg2: 	a ClassSessionHandler(SourceFileArray)
		arg3: 	[ :arg2 | arg2 startup: arg1 ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2023-04-10T18:16:44.852-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ arg2 value: arg3 ]
	Arguments and temporary variables: 
		arg1: 	Exception
		arg2: 	[ :arg4 | self errorHandler handleError: arg4 ]
	Receiver's instance variables: 
		outerContext: 	[ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4...etc...
		startpc: 	a CompiledBlock: [ arg2 value: arg3 ]
		numArgs: 	0
		receiver: 	a WorkingSession


[ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(Sessio...etc...
		arg2: 	[ :arg2 | arg2 startup: arg1 ]
		arg3: 	a ClassSessionHandler(SourceFileArray)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2023-04-10T18:16:44.852-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(SessionAccessModeResolv...etc...
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(SessionAccessModeResolv...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	an Array(a ClassSessionHandler(SmallInteger) a ClassSessionHandler(Sessio...etc...
		arg2: 	[ :arg2 | arg2 startup: arg1 ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2023-04-10T18:16:44.852-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2023-04-10T18:16:44.852-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		arg1: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection()
		id: 	nil
		creationTime: 	2023-04-10T18:16:44.852-03:00
		properties: 	a Dictionary(#accessMode->#readWrite )


SessionManager>>launchSnapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		arg1: 	true
		arg2: 	true
		tmp1: 	true
		tmp2: 	true
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
	tmp1 signal ] in SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)


[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
	tmp1 signal ]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	SessionManager>>snapshot:andQuit:
		startpc: 	a CompiledBlock: [ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
...etc...
		numArgs: 	0
		receiver: 	a SessionManager



--- The full stack ---
StartupUIManager>>inform:
PharoFilesOpener(Object)>>inform:
PharoFilesOpener>>inform:withRef:
PharoFilesOpener>>inform:withChangesRef:
PharoFilesOpener>>informProblemInChanges:
PharoFilesOpener>>changesFileOrNilReadOnly:silent:
PharoFilesOpener>>changesFileOrNilReadOnly:
PharoFilesOpener>>changesFileOrNil
SourceFileArray>>ensureOpen
SmalltalkImage>>openSourceFiles
SourceFileArray class>>startUp:
ClassSessionHandler>>startup:
[ :arg2 | arg2 startup: arg1 ] in WorkingSession>>runStartup:
[ arg2 value: arg3 ] in [ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
FullBlockClosure(BlockClosure)>>on:do:
[ :arg3 | 
		[ arg2 value: arg3 ]
			on: Exception
			do: [ :arg4 | self errorHandler handleError: arg4 ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>launchSnapshot:andQuit:
[ 
	tmp3 := self launchSnapshot: arg1 andQuit: arg2.
	tmp1 signal ] in SessionManager>>snapshot:andQuit:
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Venta class did not understand #crearCantidad:valorUnitario:
10 April 2023 6:29:09.707 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		aMessage: 	crearCantidad: 10 valorUnitario: 120
		exception: 	Instance of Venta class did not understand #crearCantidad:valorUnita...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


Venta class>>newCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		unaCantidad: 	10
		unValorUnitario: 	120
		nuevaVenta: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	nil
		nuevaVenta: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
Venta class>>newCantidad:valorUnitario:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Venta class did not understand #crearCantidad:valorUnitario:
10 April 2023 6:29:09.818 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		aMessage: 	crearCantidad: 10 valorUnitario: 120
		exception: 	Instance of Venta class did not understand #crearCantidad:valorUnita...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


Venta class>>newCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		unaCantidad: 	10
		unValorUnitario: 	120
		nuevaVenta: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	nil
		nuevaVenta: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
Venta class>>newCantidad:valorUnitario:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodeTHERE_BE_DRAGONS_HERE
Instance of Venta class did not understand #crearCantidad:valorUnitario:
10 April 2023 6:29:19.981 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		aMessage: 	crearCantidad: 10 valorUnitario: 120
		exception: 	Instance of Venta class did not understand #crearCantidad:valorUnita...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


Venta class>>newCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		unaCantidad: 	10
		unValorUnitario: 	120
		nuevaVenta: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	nil
		nuevaVenta: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	^ nuevaVenta := Venta newCantidad: 10 va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	^ nuevaVenta := Venta newCantidad: 10 va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 80) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 80) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
Venta class>>newCantidad:valorUnitario:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Venta class did not understand #crearCantidad:valorUnitario:
10 April 2023 6:29:20.062 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		aMessage: 	crearCantidad: 10 valorUnitario: 120
		exception: 	Instance of Venta class did not understand #crearCantidad:valorUnita...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


Venta class>>newCantidad:valorUnitario:
	Receiver: Venta
	Arguments and temporary variables: 
		unaCantidad: 	10
		unValorUnitario: 	120
		nuevaVenta: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearCantidad:valorUnitario:->Venta>>#crearCant...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Venta
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	nil
		nuevaVenta: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	^ nuevaVenta := Venta newCantidad: 10 va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	^ nuevaVenta := Venta newCantidad: 10 va...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 80) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 80) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
Venta class(Object)>>doesNotUnderstand: #crearCantidad:valorUnitario:
Venta class>>newCantidad:valorUnitario:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #var
10 April 2023 6:53:38.302 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #var
	Receiver: 'ventas : '
	Arguments and temporary variables: 
		aMessage: 	var
		exception: 	Instance of ByteString did not understand #var
		resumeValue: 	nil
	Receiver's instance variables: 
'ventas : '

Local>>toString
	Receiver: a Local
	Arguments and temporary variables: 
		var: 	''
	Receiver's instance variables: 
		nombreEmpresa: 	'PEPEyHERMANOS'
		coleccionVenta: 	an OrderedCollection()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	a Local
		nuevaVenta: 	a Venta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #var
Local>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #var
10 April 2023 6:53:38.379 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #var
	Receiver: 'ventas : '
	Arguments and temporary variables: 
		aMessage: 	var
		exception: 	Instance of ByteString did not understand #var
		resumeValue: 	nil
	Receiver's instance variables: 
'ventas : '

Local>>toString
	Receiver: a Local
	Arguments and temporary variables: 
		var: 	''
	Receiver's instance variables: 
		nombreEmpresa: 	'PEPEyHERMANOS'
		coleccionVenta: 	an OrderedCollection()


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	a Local
		nuevaVenta: 	a Venta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 174) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #var
Local>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #var
10 April 2023 6:54:25.575 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #var
	Receiver: 'ventas : '
	Arguments and temporary variables: 
		aMessage: 	var
		exception: 	Instance of ByteString did not understand #var
		resumeValue: 	nil
	Receiver's instance variables: 
'ventas : '

Local>>toString
	Receiver: a Local
	Arguments and temporary variables: 
		var: 	'Cantidad : 10 Valor Unitario: 120 fecha: 10 April 2023'
	Receiver's instance variables: 
		nombreEmpresa: 	'PEPEyHERMANOS'
		coleccionVenta: 	an OrderedCollection(a Venta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	a Local
		nuevaVenta: 	a Venta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 211) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 211) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #var
Local>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #var
10 April 2023 6:54:25.654 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #var
	Receiver: 'ventas : '
	Arguments and temporary variables: 
		aMessage: 	var
		exception: 	Instance of ByteString did not understand #var
		resumeValue: 	nil
	Receiver's instance variables: 
'ventas : '

Local>>toString
	Receiver: a Local
	Arguments and temporary variables: 
		var: 	'Cantidad : 10 Valor Unitario: 120 fecha: 10 April 2023'
	Receiver's instance variables: 
		nombreEmpresa: 	'PEPEyHERMANOS'
		coleccionVenta: 	an OrderedCollection(a Venta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		nuevoLocal: 	a Local
		nuevaVenta: 	a Venta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| nuevoLocal nuevaVenta |
	nuevaVenta := Venta newCantidad: 10 valo...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 211) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 211) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|nuevoLocal nuevaVenta|
nuevaVenta := Venta ne...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUnit...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|nuevoLocal nuevaVenta|
nuevaVenta := Venta newCantidad: 10 valorUn...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(231429888)
		secondArg: 	a RubEditingArea(231429888)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	1
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(231429888)
		category: 	a KMCategory
		morph: 	a RubEditingArea(231429888)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(231429888)
		directKeymaps: 	a KMCategory



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #var
Local>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:arma:
10 April 2023 7:33:10.918 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:arma:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 20 defensa: 12 vida: 120 arma: nil
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Guerrero class>>newAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		unAtaque: 	20
		unaDefensa: 	12
		unaVida: 	120
		nuevoGuerrero: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 20 defensa: 12 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 20 defensa: 12 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida: ...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida: ...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida: ...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(976478976)
		directKeymaps: 	a KMCategory



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:arma:
Guerrero class>>newAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:arma:
10 April 2023 7:33:11.002 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:arma:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 20 defensa: 12 vida: 120 arma: nil
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Guerrero class>>newAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		unAtaque: 	20
		unaDefensa: 	12
		unaVida: 	120
		nuevoGuerrero: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 20 defensa: 12 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 20 defensa: 12 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida: ...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida: ...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida: ...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 20 defensa: 12 vida...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(976478976)
		directKeymaps: 	a KMCategory



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:arma:
Guerrero class>>newAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 7:38:28.745 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 10 defensa: 120 vida: 20
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Guerrero class>>newAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		unAtaque: 	10
		unaDefensa: 	120
		unaVida: 	20
		nuevoGuerrero: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vid...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(976478976)
		directKeymaps: 	a KMCategory



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
Guerrero class>>newAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 7:38:28.83 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 10 defensa: 120 vida: 20
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Guerrero class>>newAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		unAtaque: 	10
		unaDefensa: 	120
		unaVida: 	20
		nuevoGuerrero: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vid...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(976478976)
		directKeymaps: 	a KMCategory



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
Guerrero class>>newAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
10 April 2023 7:39:20.769 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		linea: 	''
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	120
		vida: 	20
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vid...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
10 April 2023 7:39:20.859 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		linea: 	''
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	120
		vida: 	20
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 120 ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 110) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero := Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vida:...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero := Guerrero newAtaque: 10 defensa:120  vid...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(976478976)
		secondArg: 	a RubEditingArea(976478976)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	2
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(976478976)
		category: 	a KMCategory
		morph: 	a RubEditingArea(976478976)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Arma class did not understand #crearAtaque:durabilidad:tipo:
10 April 2023 9:03:34.876 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Arma class(Object)>>doesNotUnderstand: #crearAtaque:durabilidad:tipo:
	Receiver: Arma
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 10 durabilidad: 20 tipo: 'espada'
		exception: 	Instance of Arma class did not understand #crearAtaque:durabilidad:t...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearAtaque:durabilidad:tipo:->Arma>>#crearAtaq...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Arma
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Arma class>>newAtaque:durabilidad:tipo:
	Receiver: Arma
	Arguments and temporary variables: 
		unAtaque: 	10
		unaDurabilidad: 	20
		unTipo: 	'espada'
		nuevoArma: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearAtaque:durabilidad:tipo:->Arma>>#crearAtaq...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Arma
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	arma := Arma newAtaque: 10 durabilidad: 20 tipo:...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	arma := Arma newAtaque: 10 durabilidad: 20 tipo:...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''esp...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#newAtaque->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 106) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
arma := Arma newAtaque: 10 dur...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#newAtaque->nil )
		aString: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''esp...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 106) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
arma := Arma newAtaque: 10 dur...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''esp...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''e...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(306917376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(306917376)
		secondArg: 	a RubEditingArea(306917376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(306917376)
		secondArg: 	a RubEditingArea(306917376)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(306917376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(306917376)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	13
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(306917376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(306917376)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#MorphFocusCtrlNavigation) a KMCategoryBindi...etc...
		morph: 	a RubEditingArea(306917376)
		directKeymaps: 	a KMCategory



--- The full stack ---
Arma class(Object)>>doesNotUnderstand: #crearAtaque:durabilidad:tipo:
Arma class>>newAtaque:durabilidad:tipo:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Arma class did not understand #crearAtaque:durabilidad:tipo:
10 April 2023 9:03:35.002 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Arma class(Object)>>doesNotUnderstand: #crearAtaque:durabilidad:tipo:
	Receiver: Arma
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 10 durabilidad: 20 tipo: 'espada'
		exception: 	Instance of Arma class did not understand #crearAtaque:durabilidad:t...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearAtaque:durabilidad:tipo:->Arma>>#crearAtaq...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Arma
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Arma class>>newAtaque:durabilidad:tipo:
	Receiver: Arma
	Arguments and temporary variables: 
		unAtaque: 	10
		unaDurabilidad: 	20
		unTipo: 	'espada'
		nuevoArma: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#crearAtaque:durabilidad:tipo:->Arma>>#crearAtaq...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Arma
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	arma := Arma newAtaque: 10 durabilidad: 20 tipo:...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	arma := Arma newAtaque: 10 durabilidad: 20 tipo:...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''esp...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#newAtaque->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 106) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
arma := Arma newAtaque: 10 dur...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#newAtaque->nil )
		aString: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''esp...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 106) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
arma := Arma newAtaque: 10 dur...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''esp...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
arma := Arma newAtaque: 10 durabilidad:20  tipo:''e...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(306917376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(306917376)
		secondArg: 	a RubEditingArea(306917376)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(306917376)
		secondArg: 	a RubEditingArea(306917376)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(306917376)
		category: 	a KMCategory
		morph: 	a RubEditingArea(306917376)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmTHERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 9:06:50.643 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 10 defensa: 20 vida: 30
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Guerrero class>>newAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		unAtaque: 	10
		unaDefensa: 	20
		unaVida: 	30
		nuevoGuerrero: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	^ guerrero := Guerrero newAtaque: 10 defensa: 20...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	^ guerrero := Guerrero newAtaque: 10 defensa: 20...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 72) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 72) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(713080832)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(713080832)
		secondArg: 	a RubEditingArea(713080832)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(713080832)
		secondArg: 	a RubEditingArea(713080832)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(713080832)
		category: 	a KMCategory
		morph: 	a RubEditingArea(713080832)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	25
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(713080832)
		category: 	a KMCategory
		morph: 	a RubEditingArea(713080832)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(713080832)
		directKeymaps: 	a KMCategory



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
Guerrero class>>newAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 9:06:50.758 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 10 defensa: 20 vida: 30
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


Guerrero class>>newAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		unAtaque: 	10
		unaDefensa: 	20
		unaVida: 	30
		nuevoGuerrero: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	nil
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	^ guerrero := Guerrero newAtaque: 10 defensa: 20...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	^ guerrero := Guerrero newAtaque: 10 defensa: 20...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 72) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 72) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(713080832)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(713080832)
		secondArg: 	a RubEditingArea(713080832)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(713080832)
		secondArg: 	a RubEditingArea(713080832)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(713080832)
		category: 	a KMCategory
		morph: 	a RubEditingArea(713080832)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	25
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(713080832)
		category: 	a KMCategory
		morph: 	a RubEditingArea(713080832)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(713080832)
		directKeymaps: 	a KMCategory



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
Guerrero class>>newAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEveTHERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 9:13:58.753 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 100 defensa: 20 vida: 10
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	20
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand can...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(993710848)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 9:13:58.876 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 100 defensa: 20 vida: 10
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	20
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand can...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(993710848)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockCloTHERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 9:14:41.094 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 100 defensa: 20 vida: 10
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	20
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand can...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(993710848)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Guerrero class did not understand #crearAtaque:defensa:vida:
10 April 2023 9:14:41.211 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
	Receiver: Guerrero
	Arguments and temporary variables: 
		aMessage: 	crearAtaque: 100 defensa: 20 vida: 10
		exception: 	Instance of Guerrero class did not understand #crearAtaque:defensa:v...etc...
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarArma:->Guerrero>>#agregarArma: #crearAta...etc...
		format: 	65540
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Guerrero
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-TP3'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		arg1: 	SyntaxErrorNotification
		arg2: 	[ :exception | 
			self compilationContext requestor
                ifNo...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		arg1: 	Error
		arg2: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 158) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(993710848)
		secondArg: 	a RubEditingArea(993710848)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	20
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand can...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(993710848)
		category: 	a KMCategory
		morph: 	a RubEditingArea(993710848)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(993710848)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Guerrero class(Object)>>doesNotUnderstand: #crearAtaque:defensa:vida:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		resuError printing the compiledBlock in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[ 
			  self value.
			  Processor terminateRealActive ] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:06.89 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	6
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:07.012 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	6
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyTHERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:40.188 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	6
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:40.287 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	6
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. nil. nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:47.124 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	4
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:47.264 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	4
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:versioTHERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:56.911 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	2
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:05:57.012 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	2
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:06:27.725 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	1
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:06:27.831 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	1
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:06:52.732 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	1
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:06:52.846 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	1
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySTHERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:07:21.453 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	2
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:07:21.582 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	2
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntError printing the compiledBlock in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:07:45.538 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	1
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAsyncQueryResult>>buildActualResult
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
	Receiver: a ClyAsyncQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	a ClyQueryResultMetadata
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	an Announcer
		needsRebuild: 	false
		actualResult: 	nil
		buildProcess: 	a Process in nil


[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [self buildActualResult]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	ClyAsyncQueryResult>>runBuildProcess
		startpc: 	a CompiledBlock: [self buildActualResult]
		numArgs: 	0
		receiver: 	a ClyAsyncQueryResult



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #classSide
UndefinedObject>>doesNotUnderstand: #classSide
RGMetaclassDefinition>>realClass
[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
Array(SequenceableCollection)>>do:
TheManifestBuilder>>unwrap:
TheManifestBuilder>>falsePositiveOf:version:
TheManifestBuilder>>containsFalsePositive:onRule:version:
TheManifestBuilder>>bansRule:for:
[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
Array(SequenceableCollection)>>do:
Array(Collection)>>anySatisfy:
[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
OrderedCollection(SequenceableCollection)>>reject:thenDo:
ReCriticEngine>>critiquesOf:
ReCriticEngine class>>critiquesOf:
CompiledMethod>>critiques
[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
IdentitySet(Set)>>do:
ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
ClyRawQueryResult(ClyQueryResult)>>rebuild
[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
FullBlockClosure(BlockClosure)>>ensure:
[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
FullBlockClosure(BlockClosure)>>ensure:
Semaphore>>critical:
Mutex>>critical:
ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
ClyNavigationEnvironment>>query:
ClyMethodScope(ClyScope)>>query:
ClyAllBasisCritiqueQuery(ClyQuery)>>execute
ClyAsyncQueryResult>>buildActualResult
[self buildActualResult] in ClyAsyncQueryResult>>runBuildProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#classSide was sent to nil
11 April 2023 4:07:45.677 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	classSide
		exception: 	#classSide was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #classSide
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	classSide
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

RGMetaclassDefinition>>realClass
	Receiver: Arma class
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		annotations: 	nil
		name: 	#'Arma class'
		superclass: 	nil
		methods: 	an IdentityDictionary()
		protocols: 	a Set()
		instanceVariables: 	an OrderedCollection()
		organization: 	nil
		baseClass: 	Arma


[ :each | 
			rgobject := (self definitionClassFor: each first first) manifestReadOn:  (each first at: 2).
			(rgobject isClass and: [ rgobject  realClass notNil ])
				ifTrue: [ unwrapCollection add: rgobject realClass ].
			(rgobject isMethod and: [ rgobject method notNil ])
				ifTrue: [ unwrapCollection add: rgobject method ].
			(rgobject isPackage and: [ rgobject realPackage notNil ])
				ifTrue: [ unwrapCollection add: rgobject realPackage ] ] in TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
		each: 	#(#(#RGMetaclassDefinition #(#'Arma class' #Arma)) #'2023-04-09T21:08:17....etc...
		rgobject: 	Arma class
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


Array(SequenceableCollection)>>do:
	Receiver: #(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
			rgobject := (self definitionClassFor: each first first) m...etc...
		index: 	2
	Receiver's instance variables: 
#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:vida: #true)) #'2023-04-0...etc...

TheManifestBuilder>>unwrap:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		rgobject: 	Arma class
		aCollection: 	#(#(#(#RGMethodDefinition #(#'Guerrero class' #newAtaque:defensa:v...etc...
		unwrapCollection: 	an OrderedCollection()
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>falsePositiveOf:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>containsFalsePositive:onRule:version:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aItem: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		versionId: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


TheManifestBuilder>>bansRule:for:
	Receiver: ManifestBuilder of ManifestPOO
	Arguments and temporary variables: 
		aRule: 	a ReSelfSentNotImplementedRule
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		ruleId: 	'SelfSentNotImplementedRule'
		number: 	1
	Receiver's instance variables: 
		dependents: 	nil
		announcer: 	nil
		manifestClass: 	ManifestPOO


[ :banLevel |
					builder bansRule: rule for: banLevel ] in [ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
		banLevel: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
a ReCriticEngine

[:each | (aBlock value: each) ifTrue: [^ true]] in Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(SequenceableCollection)>>do:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[:each | (aBlock value: each) ifTrue: [^ true]]
		index: 	1
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

Array(Collection)>>anySatisfy:
	Receiver: {Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}
	Arguments and temporary variables: 
		aBlock: 	[ :banLevel |
					builder bansRule: rule for: banLevel ]
	Receiver's instance variables: 
{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. Guerrero}

[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForValidation
				anySatisfy: [ :banLevel |
					builder bansRule: rule for: banLevel ] ] ] in ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
		rule: 	a ReSelfSentNotImplementedRule
	Receiver's instance variables: 
a ReCriticEngine

OrderedCollection(SequenceableCollection)>>reject:thenDo:
	Receiver: an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInitialize...etc...
	Arguments and temporary variables: 
		rejectBlock: 	[ :rule |
			manifest isNotNil and:
			[ anEntity banChecksForVali...etc...
		aBlock: 	[ :rule |
			[ rule resetResult.
			  rule
				  check: anEntity
				  ...etc...
		each: 	a ReSelfSentNotImplementedRule
		index: 	21
	Receiver's instance variables: 
		array: 	an Array(a ReClassSideResetMethodProtocolRule a ReNoNilAssignationInInit...etc...
		firstIndex: 	1
		lastIndex: 	43


ReCriticEngine>>critiquesOf:
	Receiver: a ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
		rules: 	an OrderedCollection(a ReClassSideResetMethodProtocolRule a ReNoNilAssig...etc...
		critiques: 	a Set()
		manifest: 	ManifestPOO
		builder: 	ManifestBuilder of ManifestPOO
	Receiver's instance variables: 
a ReCriticEngine

ReCriticEngine class>>critiquesOf:
	Receiver: ReCriticEngine
	Arguments and temporary variables: 
		anEntity: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#critiquesOf:->ReCriticEngine>>#critiquesOf: #gu...etc...
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#ReCriticEngine
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Renraku-Utility'
		uniqueInstance: 	a ReCriticEngine


CompiledMethod>>critiques
	Receiver: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		critiques: 	nil
	Receiver's instance variables: 
Guerrero>>#crearAtaqueGuerrero:defensa:vida:

[ :each | result addAll: each critiques] in ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
		index: 	1
		each: 	Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Receiver's instance variables: 
		tally: 	1
		array: 	{Guerrero>>#crearAtaqueGuerrero:defensa:vida:. nil. nil. nil. nil. nil. ...etc...


ClyAllBasisCritiqueQuery>>analyzedObjectsDo:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aBlock: 	[ :each | result addAll: each critiques]
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyAllBasisCritiqueQuery(ClyAllCritiqueQuery)>>buildResult:
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero:defensa:vida:
	Arguments and temporary variables: 
		aQueryResult: 	a ClyRawQueryResult
		result: 	an OrderedCollection()
	Receiver's instance variables: 
		requiredResult: 	a ClyRawQueryResult
		scope: 	a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)


ClyRawQueryResult(ClyQueryResult)>>rebuild
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuild]
		
	] in ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


[
		aBlock value
	] in ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		aBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[ owner := nil ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
		startpc: 	a CompiledBlock: [
		aBlock value
	]
		numArgs: 	0
		receiver: 	a ClyRawQueryResult


[
			owner := activeProcess.
			aBlock ensure: [ owner := nil ] ] in Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


[
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	] in Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
		blockValue: 	nil
		caught: 	true
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [
		caught := true.
		self wait.
		blockValue := mutuallyExcludedBlock value
	]
	Arguments and temporary variables: 
		aBlock: 	[caught ifTrue: [self signal]]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Semaphore>>critical:
		startpc: 	a CompiledBlock: [
		caught := true.
		self wait.
		blockValue := mutu...etc...
		numArgs: 	0
		receiver: 	a Semaphore()


Semaphore>>critical:
	Receiver: a Semaphore()
	Arguments and temporary variables: 
		blockValue: 	nil
		caught: 	true
		mutuallyExcludedBlock: 	[
			owner := activeProcess.
			aBlock ensure: [ owner :...etc...
	Receiver's instance variables: 
		firstLink: 	nil
		lastLink: 	nil
		excessSignals: 	0


Mutex>>critical:
	Receiver: a Mutex
	Arguments and temporary variables: 
		aBlock: 	[
		aBlock value
	]
		activeProcess: 	a Process in nil
	Receiver's instance variables: 
		semaphore: 	a Semaphore()
		owner: 	a Process in nil


ClyRawQueryResult(ClyQueryResult)>>protectAccessWhile:
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
		aBlock: 	[
		
		needsRebuild ifTrue: [ 
			needsRebuild := false.
			self rebuil...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyRawQueryResult(ClyQueryResult)>>rebuildIfNeeded
	Receiver: a ClyRawQueryResult
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		buildingQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueG...etc...
		metadata: 	nil
		items: 	an OrderedCollection()
		accessGuard: 	a Mutex
		announcer: 	nil
		needsRebuild: 	false


ClyNavigationEnvironment>>query:
	Receiver: a ClyNavigationEnvironment
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
		result: 	a ClyRawQueryResult
	Receiver's instance variables: 
		plugins: 	an OrderedCollection(a ClyDefaultSystemEnvironmentPlugin a ClyTraitEnv...etc...
		updateStrategy: 	a ClyInstantEnvironmentUpdateStrategy
		accessGuard: 	a Mutex
		updateGuard: 	a Mutex
		system: 	a ClySystemEnvironment(Current image)
		queryCache: 	a WeakValueDictionary(a ClyAllBasisCritiqueQuery from classes: Guer...etc...


ClyMethodScope(ClyScope)>>query:
	Receiver: a ClyMethodScope(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
	Arguments and temporary variables: 
		aQuery: 	a ClyAllBasisCritiqueQuery from methods: Guerrero>>#crearAtaqueGuerrero...etc...
	Receiver's instance variables: 
		environment: 	a ClyNavigationEnvironment
		basisObjects: 	an IdentitySet(Guerrero>>#crearAtaqueGuerrero:defensa:vida:)
		name: 	nil


ClyAllBasisCritiqueQuery(ClyQuery)>>execute
	Receiver: a ClyAllBasisCritiqueQuery from methods: Guerrero>THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:18:05.046 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(471271680)
		directKeymaps: 	a KMCategory



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:18:05.194 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBTHERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:19:10.233 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(471271680)
		directKeymaps: 	a KMCategory



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:19:10.364 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	n<<error during printing>>

Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(471271680)
		directKeymaps: 	a KMCategory



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:19:17.547 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(399434752))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(399434752)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		event: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		evt: 	[(21.0@17.0) mouseUp 1131099 nil]
		all: 	an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(39273062...etc...
		m: 	a SpToolbarButtonMorph(399434752)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(392730624) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(392730624) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		evt: 	[(21.0@17.0) mouseUp 1131099 nil]
		all: 	an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(39273062...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@17.0) mouseUp 1131099 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(399434752)
	Receiver's instance variables: 
		timeStamp: 	1131099
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@17.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		focusHolder: 	a SpToolbarButtonMorph(399434752)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(256581888)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		focusHolder: 	a SpToolbarButtonMorph(399434752)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		focusHolder: 	a SpToolbarButtonMorph(399434752)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		evt: 	[(478@157) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 3 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(256581888))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1129201
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(651323648)))
		lastAlarmTime: 	1131077
		activeHand: 	a HandMorph(256581888)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1280@668)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(256581888))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1129201
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(651323648)))
		lastAlarmTime: 	1131077
		activeHand: 	a HandMorph(256581888)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1280@668)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:19:17.733 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 103) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


StPlaygroundPagePresenter>>doEvaluateAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundPagePresenter>>doEvaluateAllAndGo
	Receiver: a StPlaygroundPagePresenter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicBoxAdapter)
		announcer: 	an Announcer
		owner: 	a SpMillerColumnPresenter
		adapter: 	a SpMorphicBoxAdapter
		needRebuild: 	true
		eventHandler: 	nil
		application: 	a StPharoApplication
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ nil ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Untitled window' ]
		additionalSubpresentersMap: 	a Dictionary()
		layout: 	an ObservableValueHolder[ a SpBoxLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		text: 	a SpCodePresenter
		toolbar: 	a SpToolbarPresenter
		statusbar: 	a SpPresenter
		lineLabel: 	a SpLabelPresenter
		toggleLineNumberButton: 	a SpToggleButtonPresenter
		page: 	a StPlaygroundPage
		activationBlock: 	[ :selection | 
		self changeSelection: selection selectedItem...etc...


StPlaygroundDoItCommand>>execute
	Receiver: a StPlaygroundDoItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a StPlaygroundPagePresenter
		basicName: 	'Do it'
		basicDescription: 	'Do it all and inspect.'


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
	Receiver: a SpCommand(Do it)
	Arguments and temporary variables: 
		aButtonClass: 	nil
		specCommand: 	a SpCommand(Do it)
	Receiver's instance variables: 
		decoratedCommand: 	a StPlaygroundDoItCommand
		iconProvider: 	a StPharoApplication
		iconName: 	#glamorousGo
		shortcutKey: 	nil
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	a SpToolbarButtonPresenter


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ specCommand execute ]
	Arguments and temporary variables: 
		anArg: 	a SpToolbarButtonPresenter
	Receiver's instance variables: 
		outerContext: 	[ :specCommand | 
			aButtonClass new
				label: specCommand name...etc...
		startpc: 	a CompiledBlock: [ specCommand execute ]
		numArgs: 	0
		receiver: 	a SpCommand(Do it)


SpMorphicToolbarButtonAdapter>>execute
	Receiver: a SpMorphicToolbarButtonAdapter
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpToolbarButtonMorph(399434752))
		announcer: 	nil
		model: 	a SpToolbarButtonPresenter
		widget: 	a SpToolbarButtonMorph(399434752)
		selector: 	nil
		owner: 	a SpToolbarButtonPresenter
		unsubscribed: 	false


SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		event: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		evt: 	[(21.0@17.0) mouseUp 1131099 nil]
		all: 	an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(39273062...etc...
		m: 	a SpToolbarButtonMorph(399434752)
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
	<<error during printing>>

Array(SequenceableCollection)>>do:
	Receiver: an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(392730624) a SpToolbarBu...etc...
	Arguments and temporary variables: 
		aBlock: 	[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [...etc...
		index: 	1
	Receiver's instance variables: 
an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(392730624) a SpToolbarBu...etc...

SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		evt: 	[(21.0@17.0) mouseUp 1131099 nil]
		all: 	an Array(a SpToolbarButtonMorph(399434752) a SpToolbarButtonMorph(39273062...etc...
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleMouseUp:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


MouseButtonEvent>>sentTo:
	Receiver: [(21.0@17.0) mouseUp 1131099 nil]
	Arguments and temporary variables: 
		anObject: 	a SpToolbarButtonMorph(399434752)
	Receiver's instance variables: 
		timeStamp: 	1131099
		source: 	a HandMorph(256581888)
		windowIndex: 	nil
		type: 	#mouseUp
		buttons: 	0
		position: 	(21.0@17.0)
		handler: 	nil
		wasHandled: 	true
		whichButton: 	4


SpToolbarButtonMorph(Morph)>>handleEvent:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


SpToolbarButtonMorph(Morph)>>handleFocusEvent:
	Receiver: a SpToolbarButtonMorph(399434752)
	Arguments and temporary variables: 
		anEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(0.0@5.0) corner: (45.0@39.0)
		owner: 	a Morph(959658240)
		submorphs: 	an Array(an AlignmentMorph(460262656))
		fullBounds: 	nil
		color: 	(Color r: 0.2903225806451613 g: 0.2883675464320626 b: 0.2883675464320626...etc...
		extension: 	a MorphExtension (79051008) [balloonText]  [other:  (presenter -> a ...etc...
		borderWidth: 	0
		borderColor: 	#simple
		model: 	a SpMorphicToolbarButtonAdapter
		label: 	'Do it'
		icon: 	Form(13x13x32)
		getIconSelector: 	#icon
		getStateSelector: 	#state
		actionSelector: 	#execute
		font: 	a LogicalFont
 familyName: 'Source Sans Pro'
 emphasis: nil
 pointSize: 7...etc...
		getLabelSelector: 	#label
		getMenuSelector: 	nil
		shortcutCharacter: 	nil
		askBeforeChanging: 	false
		triggerOnMouseDown: 	false
		offColor: 	nil
		onColor: 	nil
		feedbackColor: 	nil
		showSelectionFeedback: 	false
		allButtons: 	nil
		arguments: 	#()
		argumentsProvider: 	nil
		argumentsSelector: 	nil
		enabled: 	true
		actionBlock: 	nil
		getColorSelector: 	nil
		getEnabledSelector: 	nil
		getFontSelector: 	nil
		labelMorph: 	a LabelMorph(913158144)'Do it'
		iconMorph: 	an ImageMorph(184519680)
		iconPosition: 	#top
		lastState: 	false
		badgeFont: 	nil
		badgeSelector: 	#badge


[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		focusHolder: 	a SpToolbarButtonMorph(399434752)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		result := focusHolder handleFocusEvent: transformedEvent.
	]
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :ex | 
			ActiveWorld := priorWorld.
			ex pass ]
	Receiver's instance variables: 
		outerContext: 	HandMorph>>sendFocusEvent:to:clear:
		startpc: 	a CompiledBlock: [
		result := focusHolder handleFocusEvent: transform...etc...
		numArgs: 	0
		receiver: 	a HandMorph(256581888)


WorldMorph>>becomeActiveDuring:
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
		aBlock: 	[
		result := focusHolder handleFocusEvent: transformedEvent.
	]
		priorWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


HandMorph>>sendFocusEvent:to:clear:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		result: 	nil
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		focusHolder: 	a SpToolbarButtonMorph(399434752)
		aBlock: 	[self mouseFocus: nil]
		w: 	a WorldMorph(810529024) [world]
		transformedEvent: 	[(21.0@17.0) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendEvent:focus:clear:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		focusHolder: 	a SpToolbarButtonMorph(399434752)
		aBlock: 	[self mouseFocus: nil]
		result: 	nil
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>sendMouseEvent:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


HandMorph>>handleEvent:
	Receiver: a HandMorph(256581888)
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
		evt: 	[(478@157) mouseUp 1131099 nil]
	Receiver's instance variables: 
		bounds: 	(478@157.0) corner: (494@173.0)
		owner: 	a WorldMorph(810529024) [world]
		submorphs: 	#()
		fullBounds: 	(478@157.0) corner: (494@173.0)
		color: 	Color blue
		extension: 	a MorphExtension (446869504)
		mouseFocus: 	nil
		keyboardFocus: 	a RubEditingArea(471271680)
		eventListeners: 	nil
		mouseListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(478@157) mouseUp 1131099 nil]
		targetOffset: 	(21.0@12.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 0 0 0 0 0 nil nil)
		captureBlock: 	nil
		recentModifiers: 	0
		pendingEventQueue: 	WaitfreeQueue with 0 items
		supressNextKeyPress: 	false


[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
	Receiver: an OSWindowMorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(478@157) mouseUp 1131099 nil]
	Receiver's instance variables: 
		morphicWorld: 	a WorldMorph(810529024) [world]


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
		queue: 	WaitfreeQueue with 3 items
		nextInQueue: 	[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(256581888))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1129201
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(651323648)))
		lastAlarmTime: 	1131077
		activeHand: 	a HandMorph(256581888)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1280@668)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(810529024) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(256581888))
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap()
		lastStepTime: 	1129201
		lastStepMessage: 	nil
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(651323648)))
		lastAlarmTime: 	1131077
		activeHand: 	a HandMorph(256581888)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...
		worldRenderer: 	an OSWorldRenderer
		realWindowExtent: 	(1280@668)


WorldMorph>>doOneCycleNow
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(810529024) [world]
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1280@668)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(279972352) a TaskbarMorph(101447680) a SpWin...etc...
		fullBounds: 	(0@0) corner: (1280@668)
		color: 	(Color r: 0.29521016617790813 g: 0.29521016617790813 b: 0.29521016617790...etc...
		extension: 	a MorphExtension (434896896) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.8611925708699902 g: 1.0 b: 0.7223851417399805 alpha: 1...etc...
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil


[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 
		extraWorldsToDraw: 	#()
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65547
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(81...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			    ...etc...
	Arguments and temporary variables: 
		aBlock: 	[
		self doInterCycleWait
	]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	WorldMorph class>>doOneCycle
		startpc: 	a CompiledBlock: [ 
		| extraWorldsToDraw |
		extraWorldsToDraw := Ext...etc...
		numArgs: 	0
		receiver: 	WorldMorph



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
StPlaygroundPagePresenter>>doEvaluateAndGo
StPlaygroundPagePresenter>>doEvaluateAllAndGo
StPlaygroundDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ specCommand execute ] in [ :specCommand | 
			aButtonClass new
				label: specCommand name;
				help: specCommand description;
				in: [ :button | 
					specCommand hasIcon
						ifTrue: [ button icon: specCommand icon ] ];
				action: [ specCommand execute ];
				yourself ] in SpCommand>>configureAsButtonOfClass:
FullBlockClosure(BlockClosure)>>cull:
SpMorphicToolbarButtonAdapter>>execute
SpToolbarButtonMorph(PluggableButtonMorph)>>performAction:
[:m |
		(m containsPoint: evt cursorPoint) ifTrue: [m enabled ifTrue: [ m performAction: evt ]]] in SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
Array(SequenceableCollection)>>do:
SpToolbarButtonMorph(PluggableButtonMorph)>>mouseUp:
SpToolbarButtonMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
SpToolbarButtonMorph(Morph)>>handleEvent:
SpToolbarButtonMorph(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #defensa
11 April 2023 4:19:44.153 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #defensa
	Receiver: '  '
	Arguments and temporary variables: 
		aMessage: 	defensa
		exception: 	Instance of ByteString did not understand #defensa
		resumeValue: 	nil
	Receiver's instance variables: 
'  '

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(471271680)
		directKeymaps: 	a KMCategory



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #defensa
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #defensa
11 April 2023 4:19:44.289 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #defensa
	Receiver: '  '
	Arguments and temporary variables: 
		aMessage: 	defensa
		exception: 	Instance of ByteString did not understand #defensa
		resumeValue: 	nil
	Receiver's instance variables: 
'  '

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instTHERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #defensa
11 April 2023 4:20:19.044 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #defensa
	Receiver: '  '
	Arguments and temporary variables: 
		aMessage: 	defensa
		exception: 	Instance of ByteString did not understand #defensa
		resumeValue: 	nil
	Receiver's instance variables: 
'  '

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#MorphFo...etc...
		morph: 	a RubEditingArea(471271680)
		directKeymaps: 	a KMCategory



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #defensa
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #defensa
11 April 2023 4:20:19.18 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #defensa
	Receiver: '  '
	Arguments and temporary variables: 
		aMessage: 	defensa
		exception: 	Instance of ByteString did not understand #defensa
		resumeValue: 	nil
	Receiver's instance variables: 
'  '

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 108) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(4712THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 4:34:30.558 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 200
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
200

SmallInteger(Object)>>errorNotIndexable
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

SmallInteger(Object)>>size
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		start: 	23
		stop: 	22
		replacementCollection: 	200
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'espada : 100 ataque + '

ByteString(SequenceableCollection)>>,
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		otherCollection: 	200
	Receiver's instance variables: 
'espada : 100 ataque + '

Arma>>toString
	Receiver: an Arma
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		ataque: 	100
		durabiliad: 	200
		tipo: 	'espada'


Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	an Arma


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	an Arma
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Arma>>toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 4:34:30.706 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 200
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
200

SmallInteger(Object)>>errorNotIndexable
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

SmallInteger(Object)>>size
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		start: 	23
		stop: 	22
		replacementCollection: 	200
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'espada : 100 ataque + '

ByteString(SequenceableCollection)>>,
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		otherCollection: 	200
	Receiver's instance variables: 
'espada : 100 ataque + '

Arma>>toString
	Receiver: an Arma
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		ataque: 	100
		durabiliad: 	200
		tipo: 	'espada'


Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	an Arma


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	an Arma
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	aTHERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 4:34:50.121 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 200
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
200

SmallInteger(Object)>>errorNotIndexable
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

SmallInteger(Object)>>size
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		start: 	23
		stop: 	22
		replacementCollection: 	200
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'espada : 100 ataque + '

ByteString(SequenceableCollection)>>,
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		otherCollection: 	200
	Receiver's instance variables: 
'espada : 100 ataque + '

Arma>>toString
	Receiver: an Arma
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		ataque: 	100
		durabiliad: 	200
		tipo: 	'espada'


Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	an Arma


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	an Arma
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Arma>>toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 4:34:50.264 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 200
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
200

SmallInteger(Object)>>errorNotIndexable
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

SmallInteger(Object)>>size
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		start: 	23
		stop: 	22
		replacementCollection: 	200
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'espada : 100 ataque + '

ByteString(SequenceableCollection)>>,
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		otherCollection: 	200
	Receiver's instance variables: 
'espada : 100 ataque + '

Arma>>toString
	Receiver: an Arma
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		ataque: 	100
		durabiliad: 	200
		tipo: 	'espada'


Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	an Arma


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	an Arma
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurTHERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 4:35:57.209 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 200
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
200

SmallInteger(Object)>>errorNotIndexable
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

SmallInteger(Object)>>size
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		start: 	23
		stop: 	22
		replacementCollection: 	200
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'espada : 100 ataque + '

ByteString(SequenceableCollection)>>,
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		otherCollection: 	200
	Receiver's instance variables: 
'espada : 100 ataque + '

Arma>>toString
	Receiver: an Arma
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		ataque: 	100
		durabiliad: 	200
		tipo: 	'espada'


Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	an Arma


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	an Arma
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Arma>>toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 4:35:57.349 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 200
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
200

SmallInteger(Object)>>errorNotIndexable
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

SmallInteger(Object)>>size
	Receiver: 200
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
200

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		start: 	23
		stop: 	22
		replacementCollection: 	200
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'espada : 100 ataque + '

ByteString(SequenceableCollection)>>,
	Receiver: 'espada : 100 ataque + '
	Arguments and temporary variables: 
		otherCollection: 	200
	Receiver's instance variables: 
'espada : 100 ataque + '

Arma>>toString
	Receiver: an Arma
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		ataque: 	100
		durabiliad: 	200
		tipo: 	'espada'


Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	an Arma


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	an Arma
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
<<error during printing>>
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Arma>>toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:36:51.743 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:36:51.887 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	ReceiverTHERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:37:12.852 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:37:13.001 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 256) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	ReceivTHERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:37:18.592 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 130) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 130) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:37:18.741 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 130) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 130) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil<<error during printing>>

[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:37:48.899 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 127) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 127) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#toString was sent to nil
11 April 2023 4:37:49.048 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	toString
		exception: 	#toString was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #toString
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	toString
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Guerrero>>toString
	Receiver: a Guerrero
	Arguments and temporary variables: 
		cadena: 	'10  20  30 '
	Receiver's instance variables: 
		ataque: 	10
		defensa: 	20
		vida: 	30
		arma: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		guerrero: 	a Guerrero
		arma: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| guerrero arma |
	guerrero := Guerrero newAtaque: 10 defensa: 20 v...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 127) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 127) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma|
guerrero :=Guerrero newAtaque:...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueH<<error during printing>>

SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida: 3...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|guerrero arma|
guerrero :=Guerrero newAtaque: 10 defensa: 20 vida:...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(471271680)
		secondArg: 	a RubEditingArea(471271680)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(471271680)
		category: 	a KMCategory
		morph: 	a RubEditingArea(471271680)



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #toString
UndefinedObject>>doesNotUnderstand: #toString
Guerrero>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#calcularAtaque was sent to nil
11 April 2023 5:03:37.188 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #calcularAtaque
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	calcularAtaque
		exception: 	#calcularAtaque was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #calcularAtaque
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	calcularAtaque
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Transcript show: guerrero calcularAtaque
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Transcript show: guerrero calcularAtaque
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Transcript show: guerrero calcularAtaque .'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (431 to: 472) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma |
guerrero :=Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Transcript show: guerrero calcularAtaque .'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (431 to: 472) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma |
guerrero :=Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'Transcript show: guerrero calcularAtaque .'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'Transcript show: guerrero calcularAtaque .'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(67798272)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(67798272)
		secondArg: 	a RubEditingArea(67798272)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(67798272)
		secondArg: 	a RubEditingArea(67798272)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(67798272)
		category: 	a KMCategory
		morph: 	a RubEditingArea(67798272)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: event ]
 nil on a KMK...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	15
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on ESCAPE do [ :target :morph :event | self bubbleUpEvent: ...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(67798272)
		category: 	a KMCategory
		morph: 	a RubEditingArea(67798272)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubTextEditor) a KMCategoryBinding(#RubSmal...etc...
		morph: 	a RubEditingArea(67798272)
		directKeymaps: 	a KMCategory



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #calcularAtaque
UndefinedObject>>doesNotUnderstand: #calcularAtaque
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#calcularAtaque was sent to nil
11 April 2023 5:03:37.324 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #calcularAtaque
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	calcularAtaque
		exception: 	#calcularAtaque was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #calcularAtaque
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	calcularAtaque
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Transcript show: guerrero calcularAtaque
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	^ Transcript show: guerrero calcularAtaque
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'Transcript show: guerrero calcularAtaque .'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (431 to: 472) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma |
guerrero :=Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'Transcript show: guerrero calcularAtaque .'
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (431 to: 472) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|guerrero arma |
guerrero :=Guerrero newAtaque...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'Transcript show: guerrero calcularAtaque .'
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'Transcript show: guerrero calcularAtaque .'
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporaryTHERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 5:30:05.576 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1974
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1974

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1974
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1974

SmallInteger(Object)>>size
	Receiver: 1974
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1974

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'NCuenta: '
	Arguments and temporary variables: 
		start: 	11
		stop: 	10
		replacementCollection: 	1974
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'NCuenta: '

ByteString(SequenceableCollection)>>,
	Receiver: 'NCuenta: '
	Arguments and temporary variables: 
		otherCollection: 	1974
	Receiver's instance variables: 
'NCuenta: '

Cuenta>>toString
	Receiver: a Cuenta
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		numeroCuenta: 	1974
		fechaApertura: 	11 April 2023
		monto: 	1000


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	nil
		unCliente: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro unCliente cuenta1 cuenta2 |
	cuenta1 := Cuenta newNumeroCue...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro unCliente cuenta1 cuenta2 |
	cuenta1 := Cuenta newNumeroCue...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta:1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 187) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro unCliente cuenta1 cuenta2|
cuenta1 := C...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta:1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 187) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro unCliente cuenta1 cuenta2|
cuenta1 := C...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta:1...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
SmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Cuenta>>toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: Instances of SmallInteger are not indexable
11 April 2023 5:30:05.701 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

SmallInteger(Object)>>error:
	Receiver: 1974
	Arguments and temporary variables: 
		aString: 	'Instances of SmallInteger are not indexable'
	Receiver's instance variables: 
1974

SmallInteger(Object)>>errorNotIndexable
	Receiver: 1974
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1974

SmallInteger(Object)>>size
	Receiver: 1974
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
1974

ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
	Receiver: 'NCuenta: '
	Arguments and temporary variables: 
		start: 	11
		stop: 	10
		replacementCollection: 	1974
		newSequenceableCollection: 	nil
		newSize: 	nil
		endReplacement: 	nil
	Receiver's instance variables: 
'NCuenta: '

ByteString(SequenceableCollection)>>,
	Receiver: 'NCuenta: '
	Arguments and temporary variables: 
		otherCollection: 	1974
	Receiver's instance variables: 
'NCuenta: '

Cuenta>>toString
	Receiver: a Cuenta
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		numeroCuenta: 	1974
		fechaApertura: 	11 April 2023
		monto: 	1000


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	nil
		unCliente: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro unCliente cuenta1 cuenta2 |
	cuenta1 := Cuenta newNumeroCue...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro unCliente cuenta1 cuenta2 |
	cuenta1 := Cuenta newNumeroCue...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta:1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 187) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro unCliente cuenta1 cuenta2|
cuenta1 := C...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta:1...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 187) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro unCliente cuenta1 cuenta2|
cuenta1 := C...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta:1...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro unCliente cuenta1 cuenta2|
cuenta1 := Cuenta newNumeroCuenta...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplicaTHERE_BE_DRAGONS_HERE
#agregarCliente: was sent to nil
11 April 2023 5:37:43.862 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #agregarCliente:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	agregarCliente: a Cliente
		exception: 	#agregarCliente: was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #agregarCliente:
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	agregarCliente: a Cliente
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
	Receiver: a Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	nil


Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
	Receiver: Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
		nuevoBanco: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarCliente:->Banco>>#agregarCliente: #crear...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Banco
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-2'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	nil
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNume...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #agregarCliente:
UndefinedObject>>doesNotUnderstand: #agregarCliente:
Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#agregarCliente: was sent to nil
11 April 2023 5:37:43.996 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

UndefinedObject(Object)>>doesNotUnderstand: #agregarCliente:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	agregarCliente: a Cliente
		exception: 	#agregarCliente: was sent to nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject>>doesNotUnderstand: #agregarCliente:
	Receiver: nil
	Arguments and temporary variables: 
		node: 	nil
		aMessage: 	agregarCliente: a Cliente
		exception: 	nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
	Receiver: a Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	nil


Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
	Receiver: Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
		nuevoBanco: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarCliente:->Banco>>#agregarCliente: #crear...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Banco
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-2'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	nil
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNume...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activePError printing the compiledBlock in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #agregarCliente:
UndefinedObject>>doesNotUnderstand: #agregarCliente:
Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of OrderedCollection did not understand #agregarCliente:
11 April 2023 5:38:37.425 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

OrderedCollection(Object)>>doesNotUnderstand: #agregarCliente:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aMessage: 	agregarCliente: a Cliente
		exception: 	Instance of OrderedCollection did not understand #agregarCliente:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
	Receiver: a Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection()


Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
	Receiver: Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
		nuevoBanco: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarCliente:->Banco>>#agregarCliente: #crear...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Banco
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-2'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	nil
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNume...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)



--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #agregarCliente:
Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of OrderedCollection did not understand #agregarCliente:
11 April 2023 5:38:37.562 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

OrderedCollection(Object)>>doesNotUnderstand: #agregarCliente:
	Receiver: an OrderedCollection()
	Arguments and temporary variables: 
		aMessage: 	agregarCliente: a Cliente
		exception: 	Instance of OrderedCollection did not understand #agregarCliente:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	#(nil nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	0


Banco>>crearNombre:direccion:telefono:paginaWeb:primerCliente:
	Receiver: a Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection()


Banco class>>newNombreBanco:direccion:telefono:paginaWeb:primerCliente:
	Receiver: Banco
	Arguments and temporary variables: 
		unNombre: 	'Macro'
		unaDireccion: 	'mitre 202'
		unTelefono: 	2992035
		unaPaginaWeb: 	'www.git.com'
		unCliente: 	a Cliente
		nuevoBanco: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarCliente:->Banco>>#agregarCliente: #crear...etc...
		format: 	65541
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#Banco
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-2'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	nil
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 651) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNume...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpTHERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #',\'
11 April 2023 5:53:21.96 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #',\'
	Receiver: 'HOLA ESTO ES UN '
	Arguments and temporary variables: 
		aMessage: 	,\ nil
		exception: 	Instance of ByteString did not understand #',\'
		resumeValue: 	nil
	Receiver's instance variables: 
'HOLA ESTO ES UN '

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 765) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 765) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNume...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #',\'
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of ByteString did not understand #',\'
11 April 2023 5:53:22.105 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

ByteString(Object)>>doesNotUnderstand: #',\'
	Receiver: 'HOLA ESTO ES UN '
	Arguments and temporary variables: 
		aMessage: 	,\ nil
		exception: 	Instance of ByteString did not understand #',\'
		resumeValue: 	nil
	Receiver's instance variables: 
'HOLA ESTO ES UN '

UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 |
	cuenta1 := Cuenta newN...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 765) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 765) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2|
cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNumero...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2|
cuenta1 := Cuenta newNume...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			pError printing the compiledBlock in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
ByteString(Object)>>doesNotUnderstand: #',\'
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
I am an Oups NULL debugging exception
11 April 2023 6:05:13.151 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
	Receiver: [ 
		aCompiledMethod
			valueWithReceiver: anObject
			arguments: (aCompiledMethod numArgs...etc...
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		outerContext: 	SpCodeDebugItCommand>>debug:receiver:in:
		startpc: 	a CompiledBlock: [ 
		aCompiledMethod
			valueWithReceiver: anObject
	...etc...
		numArgs: 	0
		receiver: 	a SpCodeDebugItCommand



--- The full stack ---
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of OrderedCollection did not understand #at:at:
11 April 2023 6:25:21.729 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

OrderedCollection(Object)>>doesNotUnderstand: #at:at:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aMessage: 	at: a GPoint(1,an OrderedCollection(a Cliente a Cuenta a Cuenta a Cue...etc...
		exception: 	Instance of OrderedCollection did not understand #at:at:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta a Cuenta a Cuenta nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	5


Banco>>listarClientes
	Receiver: a Banco
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta a Cuenta a ...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 lista |
	cuenta1 := Cuent...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 lista |
	cuenta1 := Cuent...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta new...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 821) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2 lista...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta new...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 821) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2 lista...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta new...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta n...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory



--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #at:at:
Banco>>listarClientes
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of OrderedCollection did not understand #at:at:
11 April 2023 6:25:21.87 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

OrderedCollection(Object)>>doesNotUnderstand: #at:at:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aMessage: 	at: a GPoint(1,an OrderedCollection(a Cliente a Cuenta a Cuenta a Cue...etc...
		exception: 	Instance of OrderedCollection did not understand #at:at:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta a Cuenta a Cuenta nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	5


Banco>>listarClientes
	Receiver: a Banco
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta a Cuenta a ...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 lista |
	cuenta1 := Cuent...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cuenta1 cuenta2 lista |
	cuenta1 := Cuent...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta new...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 821) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2 lista...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta new...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 821) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cuenta1 cuenta2 lista...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta new...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cuenta1 cuenta2 lista|
cuenta1 := Cuenta n...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver:THERE_BE_DRAGONS_HERE
Instance of OrderedCollection did not understand #at:at:
11 April 2023 6:42:58.8 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

OrderedCollection(Object)>>doesNotUnderstand: #at:at:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aMessage: 	at: a GPoint(1,an OrderedCollection(a Cliente a Cuenta a Cuenta)) at:...etc...
		exception: 	Instance of OrderedCollection did not understand #at:at:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientes
	Receiver: a Banco
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 878) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 878) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory



--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #at:at:
Banco>>listarClientes
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of OrderedCollection did not understand #at:at:
11 April 2023 6:42:58.966 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

OrderedCollection(Object)>>doesNotUnderstand: #at:at:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aMessage: 	at: a GPoint(1,an OrderedCollection(a Cliente a Cuenta a Cuenta)) at:...etc...
		exception: 	Instance of OrderedCollection did not understand #at:at:
		resumeValue: 	nil
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientes
	Receiver: a Banco
	Arguments and temporary variables: 
		cadena: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an Obser<<error during printing>>

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 878) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory



--- The full stack ---
OrderedCollection(Object)>>doesNotUnderstand: #at:at:
Banco>>listarClientes
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:52:03.989 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aBlock: 	[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unali...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
OrderedCollection>>do:
Banco>>listarClientesMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:52:04.158 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aBlock: 	[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unali...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiError printing the compiledBlock in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
OrderedCollection>>do:
Banco>>listarClientesMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:52:22.336 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aBlock: 	[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unali...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 886) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 886) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
OrderedCollection>>do:
Banco>>listarClientesMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:52:22.51 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unalista add:unCliente ] ] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>do:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		aBlock: 	[ :unCliente| (unCliente verificarMontoSuperior:unMonto)ifTrue: [ unali...etc...
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	an OrderedCollection(a Cliente)
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalComTHERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:54:08.668 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		selectBlock: 	[ :unCliente| unCliente verificarMontoSuperior:unMonto]
		newCollection: 	an OrderedCollection(a Cliente)
		element: 	a Cuenta
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
OrderedCollection>>select:
Banco>>listarClientesMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:54:08.841 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		selectBlock: 	[ :unCliente| unCliente verificarMontoSuperior:unMonto]
		newCollection: 	an OrderedCollection(a Cliente)
		element: 	a Cuenta
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	<<error during printing>>

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
OrderedCollection>>select:
Banco>>listarClientesMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:54:19.84 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		selectBlock: 	[ :unCliente| unCliente verificarMontoSuperior:unMonto]
		newCollection: 	an OrderedCollection(a Cliente)
		element: 	a Cuenta
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 931) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
OrderedCollection>>select:
Banco>>listarClientesMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 6:54:20.015 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1975
		fechaApertura: 	11 April 2023
		monto: 	6000


[ :unCliente| unCliente verificarMontoSuperior:unMonto] in Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
		unCliente: 	a Cuenta
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


OrderedCollection>>select:
	Receiver: an OrderedCollection(a Cliente a Cuenta a Cuenta)
	Arguments and temporary variables: 
		selectBlock: 	[ :unCliente| unCliente verificarMontoSuperior:unMonto]
		newCollection: 	an OrderedCollection(a Cliente)
		element: 	a Cuenta
		index: 	2
	Receiver's instance variables: 
		array: 	an Array(a Cliente a Cuenta a Cuenta nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	3


Banco>>listarClientesMontoSuperior:
	Receiver: a Banco
	Arguments and temporary variables: 
		unMonto: 	900
		unalista: 	nil
	Receiver's instance variables: 
		nombre: 	'Macro'
		direccion: 	'mitre 202'
		telefono: 	2992035
		paginaWeb: 	'www.git.com'
		coleccionClientes: 	an OrderedCollection(a Cliente a Cuenta a Cuenta)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		clienTHERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 7:00:45.543 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1974
		fechaApertura: 	11 April 2023
		monto: 	1000


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 910) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 910) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 7:00:45.72 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1974
		fechaApertura: 	11 April 2023
		monto: 	1000


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilation<<error during printing>>

FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 910) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 910) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cuenta did not understand #verificarMontoSuperior:
11 April 2023 7:01:12.653 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
	Receiver: a Cuenta
	Arguments and temporary variables: 
		aMessage: 	verificarMontoSuperior: 900
		exception: 	Instance of Cuenta did not understand #verificarMontoSuperior:
		resumeValue: 	nil
	Receiver's instance variables: 
		numeroCuenta: 	1974
		fechaApertura: 	11 April 2023
		monto: 	1000


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		Macro: 	a Banco
		cliente1: 	a Cliente
		cliente2: 	a Cliente
		cliente3: 	nil
		cuenta1: 	a Cuenta
		cuenta2: 	a Cuenta
		cuenta3: 	a Cuenta
		lista: 	nil
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3 lista |
...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1006) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary(#n->nil #r->nil )
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1006) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|Macro cliente1 cliente2 cliente3 cuenta1 cuen...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ true ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
cue...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|Macro cliente1 cliente2 cliente3 cuenta1 cuenta2 cuenta3  lista|
c...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(578468096)
		secondArg: 	a RubEditingArea(578468096)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	8
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecut...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(578468096)
		category: 	a KMCategory
		morph: 	a RubEditingArea(578468096)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(578468096)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
Cuenta(Object)>>doesNotUnderstand: #verificarMontoSuperior:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of AdministradorPinacoteca class did not understand #cr
12 April 2023 12:19:54.941 pm

VM: Win32 - x86_64 - Win64 - CoInterpreter VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
StackToRegisterMappingCogit VMMaker-tonel.1 uuid: 58d65b31-a4ab-0d00-a75e-f69302f9ba6c Dec  7 2022
v9.0.21 - Commit: 191b5a08 - Date: 2022-12-07 20:24:02 +0100

Image: Pharo10.0.0 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)]

AdministradorPinacoteca class(Object)>>doesNotUnderstand: #cr
	Receiver: AdministradorPinacoteca
	Arguments and temporary variables: 
		aMessage: 	cr
		exception: 	Instance of AdministradorPinacoteca class did not understand #cr
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#agregarPinacoteca:->AdministradorPinacoteca>>#a...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	#()
		name: 	#AdministradorPinacoteca
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'POO-7'


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 
		pinacoteca: 	a Pinacoteca
		cuadro1: 	a Cuadro
		cuadro2: 	a Cuadro
		admin: 	nil
		autor1: 	an Autor
	Receiver's instance variables: 
nil

[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| pinacoteca cuadro1 cuadro2 admin autor1 |
	cuadro1 := Cuadro
		  ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self ...etc...
	Arguments and temporary variables: 
		exception: 	SyntaxErrorNotification
		handlerAction: 	[ :exception | 
			self compilationContext requestor
           ...etc...
	Receiver's instance variables: 
		outerContext: 	OpalCompiler>>evaluate
		startpc: 	a CompiledBlock: [ receiver withArgs: (context ifNil: [ #() ] ifNotNil...etc...
		numArgs: 	0
		receiver: 	an OpalCompiler


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt

	| pinacoteca cuadro1 cuadro2 admin autor1 |
	cuadro1 := Cuadro
		  ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		aString: 	'|pinacoteca cuadro1 cuadro2 admin autor1|
cuadro1 := Cuadro newCodigo...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1053) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|pinacoteca cuadro1 cuadro2 admin autor1|
cuad...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ false ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


FullBlockClosure(BlockClosure)>>on:do:
	Receiver: [
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionMode...etc...
	Arguments and temporary variables: 
		exception: 	Error
		handlerAction: 	[ :e | e pass ]
	Receiver's instance variables: 
		outerContext: 	SpCodePresenter>>evaluate:onCompileError:onError:
		startpc: 	a CompiledBlock: [
		oldBindings := self interactionModel bindings cop...etc...
		numArgs: 	0
		receiver: 	a SpCodePresenter


SpCodePresenter>>evaluate:onCompileError:onError:
	Receiver: a SpCodePresenter
	Arguments and temporary variables: 
		receiver: 	nil
		result: 	nil
		oldBindings: 	a Dictionary()
		aString: 	'|pinacoteca cuadro1 cuadro2 admin autor1|
cuadro1 := Cuadro newCodigo...etc...
		compileErrorBlock: 	[ ^ self ]
		errorBlock: 	[ :e | e pass ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SpMorphicCodeAdapter)
		announcer: 	an Announcer
		owner: 	a StPlaygroundPagePresenter
		adapter: 	a SpMorphicCodeAdapter
		needRebuild: 	true
		eventHandler: 	a SpEventHandler
		application: 	nil
		focusOrder: 	nil
		contextKeyBindings: 	an ObservableValueHolder[ a KMCategory ]
		windowIcon: 	an ObservableValueHolder[ nil ]
		aboutText: 	an ObservableValueHolder[ nil ]
		askOkToClose: 	an ObservableValueHolder[ false ]
		titleHolder: 	an ObservableValueHolder[ 'Code' ]
		additionalSubpresentersMap: 	nil
		layout: 	an ObservableValueHolder[ a SpAbstractWidgetLayout ]
		visible: 	an ObservableValueHolder[ true ]
		extent: 	an ObservableValueHolder[ nil ]
		styles: 	#()
		borderWidth: 	an ObservableValueHolder[ nil ]
		borderColor: 	an ObservableValueHolder[ nil ]
		dragEnabled: 	an ObservableValueHolder[ false ]
		dropEnabled: 	an ObservableValueHolder[ false ]
		color: 	an ObservableValueHolder[ nil ]
		help: 	an ObservableValueHolder[ nil ]
		enabled: 	an ObservableValueHolder[ true ]
		wantsDrop: 	an ObservableValueHolder[ [ :transfer | self dropEnabled ] ]
		acceptDrop: 	an ObservableValueHolder[ [ :transfer | ] ]
		deferredActions: 	nil
		hasUnacceptedEdits: 	an ObservableValueHolder[ false ]
		selection: 	an ObservableValueHolder[ (1 to: 1053) ]
		wantsVisualFeedback: 	an ObservableValueHolder[ true ]
		askBeforeDiscardingEdits: 	an ObservableValueHolder[ true ]
		text: 	an ObservableValueHolder[ '|pinacoteca cuadro1 cuadro2 admin autor1|
cuad...etc...
		actionToPerform: 	an ObservableValueHolder[ [ :txt |  ] ]
		readSelection: 	an ObservableValueHolder[ [ selection ] ]
		placeholder: 	an ObservableValueHolder[ '' ]
		contextMenu: 	an ObservableValueHolder[ [ (self menuActionsFor: text) asMenuPres...etc...
		scrollValue: 	an ObservableValueHolder[ (0@0) ]
		editionContextMenu: 	an ObservableValueHolder[ true ]
		editable: 	an ObservableValueHolder[ true ]
		wrapWord: 	an ObservableValueHolder[ true ]
		undoRedoHistory: 	true
		wrapScrollBars: 	true
		propagateNaturalHeight: 	false
		propagateNaturalWidth: 	false
		scrollBarStyles: 	#()
		syntaxHighlight: 	an ObservableValueHolder[ true ]
		lineNumbers: 	an ObservableValueHolder[ false ]
		interactionModel: 	an ObservableValueHolder[ a StPlaygroundInteractionModel ]
		overrideContextMenu: 	true
		submitBlock: 	nil
		resetBlock: 	nil
		environment: 	nil
		systemNavigation: 	nil
		syntaxHighlightTheme: 	an ObservableValueHolder[ nil ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aString: 	'|pinacoteca cuadro1 cuadro2 admin autor1|
cuadro1 := Cuadro newCodigo...etc...
		aBlock: 	[ :result | 
		self printObject: result ]
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
		self printObject: result ]
		selection: 	'|pinacoteca cuadro1 cuadro2 admin autor1|
cuadro1 := Cuadro newCodi...etc...
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCodePrintItCommand>>execute
	Receiver: a SpCodePrintItCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		context: 	a SpCodePresenter
		basicName: 	'Print it'
		basicDescription: 	'Evaluate selection and print the result.'
		transform: 	[ :aContext | aContext ]


SpCommand(CmCommandDecorator)>>execute
	Receiver: a SpCommand(Print it)
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCodePrintItCommand
		iconProvider: 	nil
		iconName: 	#smallPrintIt
		shortcutKey: 	a KMKeyCombinationChoice
		displayStrategy: 	a CmUIDisableWhenCantBeRun
		positionStrategy: 	a CmUILeftPositionStrategy
		buildPresenterBlock: 	[ :specCommand | 
			aButtonClass new
				label: specComma...etc...
		presenter: 	nil


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	a StPharoApplication
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpCommand(Print it)


[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


FullBlockClosure(BlockClosure)>>ensure:
	Receiver: [ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ 
			activeProcess
				psValueAt: index
				put: oldValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	SpToolCurrentApplication(DynamicVariable)>>value:during:
		startpc: 	a CompiledBlock: [ activeProcess
			psValueAt: index
			put: anObject....etc...
		numArgs: 	0
		receiver: 	a SpToolCurrentApplication


SpToolCurrentApplication(DynamicVariable)>>value:during:
	Receiver: a SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
		activeProcess: 	a Process in nil
		oldValue: 	nil
	Receiver's instance variables: 
		index: 	12


SpToolCurrentApplication class(DynamicVariable class)>>value:during:
	Receiver: SpToolCurrentApplication
	Arguments and temporary variables: 
		anObject: 	a StPharoApplication
		aBlock: 	[ self decoratedCommand execute ]
	Receiver's instance variables: 
		superclass: 	DynamicVariable
		methodDict: 	a MethodDictionary()
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SpToolCurrentApplication
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Spec2-Commands-Presenters'
		soleInstance: 	a SpToolCurrentApplication


SpToolCurrentApplicationCommand>>execute
	Receiver: a SpToolCurrentApplicationCommand
	Arguments and temporary variables: 
x
	Receiver's instance variables: 
		decoratedCommand: 	a SpToolCurrentApplicationCommand


[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
	Receiver: a SpKMCategoryBuilder
	Arguments and temporary variables: 
		aCmCommand: 	a SpToolCurrentApplicationCommand
	Receiver's instance variables: 
		kmCategory: 	a KMCategory


FullBlockClosure(BlockClosure)>>cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		anArg: 	a RubEditingArea(474864896)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(474864896)
		secondArg: 	a RubEditingArea(474864896)
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


FullBlockClosure(BlockClosure)>>cull:cull:cull:
	Receiver: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
	Arguments and temporary variables: 
		firstArg: 	a RubEditingArea(474864896)
		secondArg: 	a RubEditingArea(474864896)
		thirdArg: 	[keyDown '<Ctrl-p>']
	Receiver's instance variables: 
		outerContext: 	SpKMCategoryBuilder>>visitCommand:
		startpc: 	a CompiledBlock: [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComm...etc...
		numArgs: 	0
		receiver: 	a SpKMCategoryBuilder


KMCategoryBinding>>completeMatch:buffer:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		aKeymap: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
			...etc...
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
	Receiver's instance variables: 
		target: 	a RubEditingArea(474864896)
		category: 	a KMCategory
		morph: 	a RubEditingArea(474864896)


[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		l: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Arguments and temporary variables: 
		aBlock: 	[ :l | l completeMatch: self buffer: aBuffer ]
		index: 	1
	Receiver's instance variables: 
an Array(a KMCategoryBinding(nil) a KMDispatcher)

KMKeymap>>notifyCompleteMatchTo:buffer:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		aListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		listeners: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


KMKeymap>>onMatchWith:notify:andDo:
	Receiver: nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmComman...etc...
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		action: 	[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ]
		name: 	nil
		shortcut: 	a KMKeyCombinationChoice
		defaultShortcut: 	a KMKeyCombinationChoice
		description: 	nil


[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
		entry: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				i...etc...
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


Set>>do:
	Receiver: a Set(nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCm...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListen...etc...
		index: 	18
		each: 	nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeExecuted 
				if...etc...
	Receiver's instance variables: 
		tally: 	31
		array: 	an Array(nil nil on a KMKeyCombinationChoice do [ 
			aCmCommand canBeEx...etc...


KMCategory>>onMatchWith:notify:andDo:
	Receiver: a KMCategory
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aMatchListener: 	an Array(a KMCategoryBinding(nil) a KMDispatcher)
		aBlock: 	[ ^self ]
	Receiver's instance variables: 
		name: 	nil
		platforms: 	a Dictionary(#Windows->a KMStorage #all->a KMStorage )


KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
	Receiver: a KMCategoryBinding(nil)
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aListener: 	a KMDispatcher
		anAction: 	[ ^self ]
	Receiver's instance variables: 
		target: 	a RubEditingArea(474864896)
		category: 	a KMCategory
		morph: 	a RubEditingArea(474864896)


[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
	Receiver: a KMDispatcher
	Arguments and temporary variables: 
		anEventBuffer: 	an OrderedCollection([keyDown '<Ctrl-p>'])
		aTarget: 	a KMCategoryBinding(nil)
	Receiver's instance variables: 
		target: 	a KMTarget
		currentEvent: 	nil
		targets: 	a Set(a KMCategoryBinding(#RubSmalltalkEditor) a KMCategoryBinding(#Mo...etc...
		morph: 	a RubEditingArea(474864896)
		directKeymaps: 	a KMCategory


OrderedCollection>>do:
	Receiver: an OrderedCollection(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEditor) a K...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
		...etc...
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(a KMCategoryBinding(nil) a KMCategoryBinding(#RubSmalltalkEdito...etc...
		firstIndex: 	1
		lastIndex: 	4



--- The full stack ---
AdministradorPinacoteca class(Object)>>doesNotUnderstand: #cr
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError:
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during:
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand:
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | 
		entry onMatchWith: anEventBuffer 
			notify: aMatchListener 
			andDo: aBlock ] in KMCategory>>onMatchWith:notify:andDo:
Set>>do:
KMCategory>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
		"nice hack to stop in the first listener"
		aTarget 
			verifyMatchWith: anEventBuffer 
			notifying: self
			thenDoing: [ ^self ] ] in KMDispatcher>>dispatch:
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
KMDispatcher>>dispatch:
KMTarget>>dispatch:
[ :targetToDispatch |
		targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
		aKeyboardEvent wasHandled ifTrue: [ ^self ].
	] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(Morph)>>handleKeystrokeWithKeymappings:
KMShortcutHandler>>handleKeystroke:inMorph:
RubEditingArea(Morph)>>handleKeyDown:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[
		result := focusHolder handleFocusEvent: transformedEvent.
	] in HandMorph>>sendFocusEvent:to:clear:
FullBlockClosure(BlockClosure)>>on:do:
WorldMorph>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle
FullBlockClosure(BlockClosure)>>ensure:
WorldState class>>doDrawCycleWith:
WorldMorph class>>doOneCycle
MorphicRenderLoop>>doOneCycle
MorphicRenderLoop>>doOneCycleWhile:
[
		MorphicRenderLoop new doOneCycleWhile: [ true ]
	] in MorphicUIManager>>spawnNewProcess
[self value.
			"IMPORTANT: Do not step over next line of code. See method comments for details"
			Processor terminateRealActive] in FullBlockClosure(BlockClosure)>>newProcess
-------------------------------------------------------------------------------

