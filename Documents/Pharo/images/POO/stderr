[31mInstance of Artista did not understand #toString
[0mArtista(Object)>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Artista did not understand #toString
[0mArtista(Object)>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Artista did not understand #toString
[0mArtista(Object)>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Artista did not understand #toString
[0mArtista(Object)>>doesNotUnderstand: #toString
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Artista did not understand #especialidadArtista
[0mArtista(Object)>>doesNotUnderstand: #especialidadArtista
[:unArtista| (unArtista especialidadArtista) =unTipo ] in Fiesta>>obtenerArtistasDeTipo: in Block: [:unArtista| (unArtista especialidadArtista) =unTi...etc...
OrderedCollection>>select:
Fiesta>>obtenerArtistasDeTipo:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
[0m[31mInstance of Artista did not understand #especialidadArtista
[0mArtista(Object)>>doesNotUnderstand: #especialidadArtista
[:unArtista| (unArtista especialidadArtista) =unTipo ] in Fiesta>>obtenerArtistasDeTipo: in Block: [:unArtista| (unArtista especialidadArtista) =unTi...etc...
OrderedCollection>>select:
Fiesta>>obtenerArtistasDeTipo:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
[0m[31mInstance of Artista did not understand #especialidadArtista
[0mArtista(Object)>>doesNotUnderstand: #especialidadArtista
[:unArtista| (unArtista especialidadArtista) =unTipo ] in Fiesta>>obtenerArtistasDeTipo: in Block: [:unArtista| (unArtista especialidadArtista) =unTi...etc...
OrderedCollection>>select:
Fiesta>>obtenerArtistasDeTipo:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
[0m[31mInstance of Artista did not understand #especialidadArtista
[0mArtista(Object)>>doesNotUnderstand: #especialidadArtista
[:unArtista| (unArtista especialidadArtista) =unTipo ] in Fiesta>>obtenerArtistasDeTipo: in Block: [:unArtista| (unArtista especialidadArtista) =unTi...etc...
OrderedCollection>>select:
Fiesta>>obtenerArtistasDeTipo:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
[0m[31m#do: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #do:
UndefinedObject>>doesNotUnderstand: #do:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#do: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #do:
UndefinedObject>>doesNotUnderstand: #do:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0mMouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31m#askOkToClose was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #askOkToClose
UndefinedObject>>doesNotUnderstand: #askOkToClose
SpWindow>>allowedToClose
ToggleMenuItemMorph>>isEnabled
ToggleMenuItemMorph>>select:
MenuMorph>>selectItem:event:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnterDragging:
ToggleMenuItemMorph(MenuItemMorph)>>mouseEnter:
ToggleMenuItemMorph>>mouseEnter:
ToggleMenuItemMorph(Morph)>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
		self inform: asMouseEnterEvent to: anEnteredMorph originatedFrom: anEvent ifNotFocusedDo: [] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
[
		(morphicWorld activeHand isNotNil and: [ anEvent hand isNotNil ]) ifTrue: [
			morphicWorld activeHand handleEvent: anEvent
		]
	] in OSWindowMorphicEventHandler>>dispatchMorphicEvent: in Block: [...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycleNow
WorldMorph>>doOneCycle
[ 
		| extraWorldsToDraw |
		extraWorldsToDraw := ExtraWorldListMutex critical: [ 
			                     self extraWorldList ].
		extraWorldsToDraw do: [ :world | world doOneCycle ].

		(self currentWorld isNotNil and: [ 
			 (extraWorldsToDraw includes: self currentWorld) not ]) ifTrue: [ 
			self currentWorld doOneCycle ] ] in WorldMorph class>>doOneCycle in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
[0m self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mInstance of SmallInteger did not understand #month
[0mSmallInteger(Object)>>doesNotUnderstand: #month
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of SmallInteger did not understand #month
[0mSmallInteger(Object)>>doesNotUnderstand: #month
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mError: Number is an abstract class.  Make a concrete subclass.
[0mNumber class(Object)>>error:
Number class>>new
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mError: Number is an abstract class.  Make a concrete subclass.
[0mNumber class(Object)>>error:
Number class>>new
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of Date did not understand #mmyyyy
[0mDate(Object)>>doesNotUnderstand: #mmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #mmyyyy
[0mDate(Object)>>doesNotUnderstand: #mmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yyyymm
[0mDate(Object)>>doesNotUnderstand: #yyyymm
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yyyymm
[0mDate(Object)>>doesNotUnderstand: #yyyymm
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yyyymm
[0mDate(Object)>>doesNotUnderstand: #yyyymm
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yyyymm
[0mDate(Object)>>doesNotUnderstand: #yyyymm
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #month:year:
[0mDate(Object)>>doesNotUnderstand: #month:year:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #month:year:
[0mDate(Object)>>doesNotUnderstand: #month:year:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31m#month:year: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #month:year:
UndefinedObject>>doesNotUnderstand: #month:year:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#month:year: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #month:year:
UndefinedObject>>doesNotUnderstand: #month:year:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of SmallInteger did not understand #ddmmyyyy
[0mSmallInteger(Object)>>doesNotUnderstand: #ddmmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of SmallInteger did not understand #ddmmyyyy
[0mSmallInteger(Object)>>doesNotUnderstand: #ddmmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31m#year:week:day: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #year:week:day:
UndefinedObject>>doesNotUnderstand: #year:week:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#year:week:day: was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #year:week:day:
UndefinedObject>>doesNotUnderstand: #year:week:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of Date did not understand #year:week:day:
[0mDate(Object)>>doesNotUnderstand: #year:week:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #year:week:day:
[0mDate(Object)>>doesNotUnderstand: #year:week:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #year:week:day:
[0mDate(Object)>>doesNotUnderstand: #year:week:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #year:week:day:
[0mDate(Object)>>doesNotUnderstand: #year:week:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date class did not understand #year:month:
[0mDate class(Object)>>doesNotUnderstand: #year:month:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date class did not understand #year:month:
[0mDate class(Object)>>doesNotUnderstand: #year:month:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of SmallInteger did not understand #ddmmyyyy
[0mSmallInteger(Object)>>doesNotUnderstand: #ddmmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of SmallInteger did not understand #ddmmyyyy
[0mSmallInteger(Object)>>doesNotUnderstand: #ddmmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of ByteString did not understand #month
[0mByteString(Object)>>doesNotUnderstand: #month
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of ByteString did not understand #month
[0mByteString(Object)>>doesNotUnderstand: #month
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #mm
[0mDate(Object)>>doesNotUnderstand: #mm
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #mm
[0mDate(Object)>>doesNotUnderstand: #mm
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yyyy
[0mDate(Object)>>doesNotUnderstand: #yyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yyyy
[0mDate(Object)>>doesNotUnderstand: #yyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yy
[0mDate(Object)>>doesNotUnderstand: #yy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date did not understand #yy
[0mDate(Object)>>doesNotUnderstand: #yy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mDateError: day may not be zero or negative
[0mDateAndTime class>>year:month:day:hour:minute:second:nanoSecond:offset:
DateAndTime class>>year:month:day:hour:minute:second:offset:
DateAndTime class>>year:month:day:hour:minute:second:
DateAndTime class>>year:month:day:hour:minute:
DateAndTime class>>year:month:day:
Date class>>year:month:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
[0m[31mDateError: day may not be zero or negative
[0mDateAndTime class>>year:month:day:hour:minute:second:nanoSecond:offset:
DateAndTime class>>year:month:day:hour:minute:second:offset:
DateAndTime class>>year:month:day:hour:minute:second:
DateAndTime class>>year:month:day:hour:minute:
DateAndTime class>>year:month:day:
Date class>>year:month:day:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
[0m[31mInstance of Date class did not understand #year:month:
[0mDate class(Object)>>doesNotUnderstand: #year:month:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Date class did not understand #year:month:
[0mDate class(Object)>>doesNotUnderstand: #year:month:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of ByteString did not understand #subtracDate:
[0mByteString(Object)>>doesNotUnderstand: #subtracDate:
Cliente>>verificarVencimiento
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of ByteString did not understand #subtracDate:
[0mByteString(Object)>>doesNotUnderstand: #subtracDate:
Cliente>>verificarVencimiento
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of ByteString did not understand #subtracDate:
[0mByteString(Object)>>doesNotUnderstand: #subtracDate:
Cliente>>verificarVencimiento
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of ByteString did not understand #subtracDate:
[0mByteString(Object)>>doesNotUnderstand: #subtracDate:
Cliente>>verificarVencimiento
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of Date did not understand #days
[0mDate(Object)>>doesNotUnderstand: #days
Date>>subtractDays:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of Date did not understand #days
[0mDate(Object)>>doesNotUnderstand: #days
Date>>subtractDays:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#verificarVencimiento was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #verificarVencimiento
UndefinedObject>>doesNotUnderstand: #verificarVencimiento
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#verificarVencimiento was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #verificarVencimiento
UndefinedObject>>doesNotUnderstand: #verificarVencimiento
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodeDoItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodeDoItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#year was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #year
UndefinedObject>>doesNotUnderstand: #year
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31m#year was sent to nil
[0mUndefinedObject(Object)>>doesNotUnderstand: #year
UndefinedObject>>doesNotUnderstand: #year
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[0m[31mInstance of Vagon did not understand #crearAnio:
[0mVagon(Object)>>doesNotUnderstand: #crearAnio:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Vagon did not understand #crearAnio:
[0mVagon(Object)>>doesNotUnderstand: #crearAnio:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Vagon did not understand #crearAnio:
[0mVagon(Object)>>doesNotUnderstand: #crearAnio:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Vagon did not understand #crearAnio:
[0mVagon(Object)>>doesNotUnderstand: #crearAnio:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mInvalidGlobalName: artista: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
[0mShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
			builder
				superclass: self;
				name: t;
				layoutClass: self classLayout class;
				slots: f asSlotCollection;
				sharedVariablesFromString: d;
				sharedPools: s;
				category: cat;
				environment: self environment ] in Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package: in Block: [ :builder | ...
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmInsertSubclassCommand>>executeRefactoring
[self prepareFullExecution.
	self executeRefactoring.
	self applyCommandResult] in SycCmInsertSubclassCommand(SycCmCommand)>>execute in Block: [self prepareFullExecution....
FullBlockClosure(BlockClosure)>>on:do:
SycCmInsertSubclassCommand(SycCmCommand)>>execute
SycCmInsertSubclassCommand(Object)>>perform:orSendTo:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mInvalidGlobalName: artista: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
[0mShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
			builder
				superclass: self;
				name: t;
				layoutClass: self classLayout class;
				slots: f asSlotCollection;
				sharedVariablesFromString: d;
				sharedPools: s;
				category: cat;
				environment: self environment ] in Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package: in Block: [ :builder | ...
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmInsertSubclassCommand>>executeRefactoring
[self prepareFullExecution.
	self executeRefactoring.
	self applyCommandResult] in SycCmInsertSubclassCommand(SycCmCommand)>>execute in Block: [self prepareFullExecution....
FullBlockClosure(BlockClosure)>>on:do:
SycCmInsertSubclassCommand(SycCmCommand)>>execute
SycCmInsertSubclassCommand(Object)>>perform:orSendTo:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mInvalidGlobalName: unArtista: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
[0mShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
			builder
				superclass: self;
				name: t;
				layoutClass: self classLayout class;
				slots: f asSlotCollection;
				sharedVariablesFromString: d;
				sharedPools: s;
				category: cat;
				environment: self environment ] in Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package: in Block: [ :builder | ...
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmAddSubclassCommand>>executeRefactoring
[self prepareFullExecution.
	self executeRefactoring.
	self applyCommandResult] in SycCmAddSubclassCommand(SycCmCommand)>>execute in Block: [self prepareFullExecution....
FullBlockClosure(BlockClosure)>>on:do:
SycCmAddSubclassCommand(SycCmCommand)>>execute
SycCmAddSubclassCommand(Object)>>perform:orSendTo:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mInvalidGlobalName: unArtista: Class name is not a valid global name. It must start with uppercase letter and continue with alphanumeric characters or underscore. Default names used in class or trait templates are not allowed.
[0mShiftClassBuilder>>validateClassName
ShiftClassBuilder>>name:
[ :builder | 
			builder
				superclass: self;
				name: t;
				layoutClass: self classLayout class;
				slots: f asSlotCollection;
				sharedVariablesFromString: d;
				sharedPools: s;
				category: cat;
				environment: self environment ] in Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package: in Block: [ :builder | ...
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Fiesta class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmAddSubclassCommand>>executeRefactoring
[self prepareFullExecution.
	self executeRefactoring.
	self applyCommandResult] in SycCmAddSubclassCommand(SycCmCommand)>>execute in Block: [self prepareFullExecution....
FullBlockClosure(BlockClosure)>>on:do:
SycCmAddSubclassCommand(SycCmCommand)>>execute
SycCmAddSubclassCommand(Object)>>perform:orSendTo:
[ | selArgCount |  "show cursor in case item opens a new MVC window"
		(selArgCount := selector numArgs) = 0
			ifTrue:
				[target perform: selector]
			ifFalse:
				[selArgCount = arguments size
					ifTrue: [target perform: selector withArguments: arguments]
					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]].
		self showShortcut.
		self changed] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent: in Block: [ | selArgCount |  "show cursor in case item opens...etc...
FullBlockClosure(BlockClosure)>>ensure:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mDuplicatedSlotName: Slot #'nombre' appeared twice in Artista
[0m[ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ] in [ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :anotherSlot | ...
Array(SequenceableCollection)>>do:
[ :aSubclass | 
		aSubclass slots do: [ :anotherSlot | 
			(slotNames includes: anotherSlot name) ifTrue: [ 
				DuplicatedSlotName new
						oldSlot: anotherSlot;
						newSlot: nil;
						host: aSubclass;
						signal 
			] ]	 ] in ShLayoutDefinition>>validate in Block: [ :aSubclass | ...
Array(SequenceableCollection)>>do:
Fiesta class(Class)>>subclassesDo:
ShLayoutDefinition>>validate
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[ 
	newClass := (self classCompilerFor: oldClass)
		            source: newClassDefinitionString;
		            requestor: aController;
		            failBlock: [ ^ nil ];
		            logged: true;
		            evaluate ] in ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom: in Block: [ ...
FullBlockClosure(BlockClosure)>>on:do:
ClySystemEnvironment>>defineNewClassFrom:notifying:startingFrom:
ClySystemEnvironment>>compileANewClassFrom:notifying:startingFrom:
ClyFullBrowserMorph>>compileANewClassFrom:notifying:startingFrom:
ClyClassDefinitionEditorToolMorph>>applyChangesAsClassDefinition
ClyClassDefinitionEditorToolMorph>>applyChanges
[self changesAreAboutApply.
		applied := self applyChanges] in [ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [self changesAreAboutApply....
FullBlockClosure(BlockClosure)>>on:do:
[ 
		textMorph hasUnacceptedEdits: true.
		[self changesAreAboutApply.
		applied := self applyChanges] on: Error do: [ :err | 
			textModel text: self editingText. 
			textMorph hasUnacceptedEdits: true.
			err pass].	
		applied 
			ifTrue: [ textMorph hasUnacceptedEdits: false. 
				self textUpdated.
				browser focusActiveTab ]
			ifFalse: [ 
				textModel text: self editingText. 
				textMorph hasUnacceptedEdits: true].
	] in ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>changesAccepted in Block: [ ...
FullBlockClosure(BlockClosure)>>ensure:
ClyClassDefinitionEditorToolMorph(ClyTextEditorToolMorph)>>applyChangesBy:
[0m[31mCircularHierarchyError: Fiesta: Trying to build a circular hierarchy
[0m[ :aSuperclass |
		aSuperclass = oldClass ifTrue:[
			CircularHierarchyError signalFor: oldClass ]] in ShiftClassBuilder>>validateSuperclass in Block: [ :aSuperclass |...
Fiesta class(Behavior)>>withAllSuperclassesDo:
POO class(Behavior)>>withAllSuperclassesDo:
AR class(Behavior)>>withAllSuperclassesDo:
ShiftClassBuilder>>validateSuperclass
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
AR class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
AR class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmInsertSubclassCommand>>executeRefactoring
[0m[31mCircularHierarchyError: Fiesta: Trying to build a circular hierarchy
[0m[ :aSuperclass |
		aSuperclass = oldClass ifTrue:[
			CircularHierarchyError signalFor: oldClass ]] in ShiftClassBuilder>>validateSuperclass in Block: [ :aSuperclass |...
Fiesta class(Behavior)>>withAllSuperclassesDo:
POO class(Behavior)>>withAllSuperclassesDo:
AR class(Behavior)>>withAllSuperclassesDo:
ShiftClassBuilder>>validateSuperclass
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
AR class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
AR class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmInsertSubclassCommand>>executeRefactoring
[0m[31mCircularHierarchyError: POO: Trying to build a circular hierarchy
[0m[ :aSuperclass |
		aSuperclass = oldClass ifTrue:[
			CircularHierarchyError signalFor: oldClass ]] in ShiftClassBuilder>>validateSuperclass in Block: [ :aSuperclass |...
POO class(Behavior)>>withAllSuperclassesDo:
Artista2 class(Behavior)>>withAllSuperclassesDo:
ShiftClassBuilder>>validateSuperclass
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Artista2 class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Artista2 class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmInsertSubclassCommand>>executeRefactoring
[self prepareFullExecution.
	self executeRefactoring.
	self applyCommandResult] in SycCmInsertSubclassCommand(SycCmCommand)>>execute in Block: [self prepareFullExecution....
[0m[31mCircularHierarchyError: POO: Trying to build a circular hierarchy
[0m[ :aSuperclass |
		aSuperclass = oldClass ifTrue:[
			CircularHierarchyError signalFor: oldClass ]] in ShiftClassBuilder>>validateSuperclass in Block: [ :aSuperclass |...
POO class(Behavior)>>withAllSuperclassesDo:
Artista2 class(Behavior)>>withAllSuperclassesDo:
ShiftClassBuilder>>validateSuperclass
ShiftClassBuilder>>build
[	
		builder oldClass: oldClass.
		self copyClassSlotsFromExistingClass.
		newClass := builder build.

		self installInEnvironment: newClass.

		self installSubclassInSuperclass: newClass.
	
		builder builderEnhancer beforeMigratingClass: builder installer: self.

		builder builderEnhancer migrateToClass: newClass installer: self.

		builder builderEnhancer afterMigratingClass: builder installer: self.	

		builder builderEnhancer propagateChangesToRelatedClasses: newClass installer: self.
	] in ShiftClassInstaller>>make in Block: [	...
FullBlockClosure(BlockClosure)>>on:do:
ShiftClassInstaller>>make
ShiftClassInstaller>>make:
ShiftClassInstaller class>>make:
Artista2 class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
Artista2 class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
SystemDictionary>>defineClass:withController:
RBAddClassChange(RBRefactoryDefinitionChange)>>primitiveExecute
RBAddClassChange(RBRefactoryClassChange)>>executeNotifying:
[ :each | each executeNotifying: aBlock ] in RBCompositeRefactoryChange>>executeNotifying: in Block: [ :each | each executeNotifying: aBlock ]
OrderedCollection>>collect:
RBCompositeRefactoryChange>>executeNotifying:
RBCompositeRefactoryChange(RBRefactoryChange)>>execute
[ self addUndo: aRefactoringChange execute ] in RBRefactoryChangeManager>>performChange: in Block: [ self addUndo: aRefactoringChange execute ]
FullBlockClosure(BlockClosure)>>ensure:
RBRefactoryChangeManager>>ignoreChangesWhile:
RBRefactoryChangeManager>>performChange:
RBAddClassRefactoring(RBRefactoring)>>execute
SycCmInsertSubclassCommand>>executeRefactoring
[self prepareFullExecution.
	self executeRefactoring.
	self applyCommandResult] in SycCmInsertSubclassCommand(SycCmCommand)>>execute in Block: [self prepareFullExecution....
[0m[31mInstance of Artista class did not understand #crearNombre:apellido:tipo:dni:telefono:email:
[0mArtista class(Object)>>doesNotUnderstand: #crearNombre:apellido:tipo:dni:telefono:email:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Artista class did not understand #crearNombre:apellido:tipo:dni:telefono:email:
[0mArtista class(Object)>>doesNotUnderstand: #crearNombre:apellido:tipo:dni:telefono:email:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Artista>>imprimir
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Artista>>imprimir
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Artista>>imprimir
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
[0m[31mError: Instances of SmallInteger are not indexable
[0mSmallInteger(Object)>>error:
SmallInteger(Object)>>errorNotIndexable
SmallInteger(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
Artista>>imprimir
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
[0m[31mInstance of ByteString did not understand #unaFiesta
[0mByteString(Object)>>doesNotUnderstand: #unaFiesta
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of ByteString did not understand #unaFiesta
[0mByteString(Object)>>doesNotUnderstand: #unaFiesta
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Fiesta class did not understand #haParticipado:
[0mFiesta class(Object)>>doesNotUnderstand: #haParticipado:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Fiesta class did not understand #haParticipado:
[0mFiesta class(Object)>>doesNotUnderstand: #haParticipado:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Fiesta class did not understand #haParticipado:
[0mFiesta class(Object)>>doesNotUnderstand: #haParticipado:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of Fiesta class did not understand #haParticipado:
[0mFiesta class(Object)>>doesNotUnderstand: #haParticipado:
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mError: Instances of True are not indexable
[0mTrue(Object)>>error:
True(Object)>>errorNotIndexable
True(Object)>>size
ByteString(SequenceableCollection)>>copyReplaceFrom:to:with:
ByteString(SequenceableCollection)>>,
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
[0m[31mInstance of SmallInteger did not understand #ddmmyyyy
[0mSmallInteger(Object)>>doesNotUnderstand: #ddmmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m[31mInstance of SmallInteger did not understand #ddmmyyyy
[0mSmallInteger(Object)>>doesNotUnderstand: #ddmmyyyy
UndefinedObject>>DoIt
[ receiver withArgs: (context ifNil: [ #() ] ifNotNil: [ {context} ]) executeMethod: self compileDoit] in OpalCompiler>>evaluate in Block: [ receiver withArgs: (context ifNil: [ #() ] ifNot...etc...
FullBlockClosure(BlockClosure)>>on:do:
OpalCompiler>>evaluate
[
		oldBindings := self interactionModel bindings copy.
		receiver := self interactionModel doItReceiver.
		result := receiver class compiler
			source: aString readStream;
			context: self interactionModel doItContext;
			receiver: self interactionModel doItReceiver;
			requestor: self interactionModel;
			environment: self environment;
			failBlock:  [ ^ compileErrorBlock value ];
			evaluate.
		oldBindings size = self interactionModel bindings size 
			ifFalse: [ self withAdapterDo: [ :anAdapter | anAdapter refreshStyling ] ].
		result ] in SpCodePresenter>>evaluate:onCompileError:onError: in Block: [...
FullBlockClosure(BlockClosure)>>on:do:
SpCodePresenter>>evaluate:onCompileError:onError:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluate:andDo:
SpCodePrintItCommand(SpCodeSelectionCommand)>>evaluateSelectionAndDo:
SpCodePrintItCommand>>execute
SpCommand(CmCommandDecorator)>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ self decoratedCommand execute ] in SpToolCurrentApplicationCommand>>execute in Block: [ self decoratedCommand execute ]
[ activeProcess
			psValueAt: index
			put: anObject.
		aBlock value ] in SpToolCurrentApplication(DynamicVariable)>>value:during: in Block: [ activeProcess...
FullBlockClosure(BlockClosure)>>ensure:
SpToolCurrentApplication(DynamicVariable)>>value:during:
SpToolCurrentApplication class(DynamicVariable class)>>value:during:
SpToolCurrentApplicationCommand>>execute
[ 
			aCmCommand canBeExecuted 
				ifTrue: [ aCmCommand execute ] ] in SpKMCategoryBuilder>>visitCommand: in Block: [ ...
FullBlockClosure(BlockClosure)>>cull:
FullBlockClosure(BlockClosure)>>cull:cull:
FullBlockClosure(BlockClosure)>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer: in Block: [ :l | l completeMatch: self buffer: aBuffer ]
[0m